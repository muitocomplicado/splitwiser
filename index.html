<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Splitwiser</title>

    <!-- PWA Manifest -->
    <link rel="manifest" href="manifest.json">

    <!-- iOS PWA Meta Tags -->
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-status-bar-style" content="default">
    <meta name="mobile-web-app-title" content="Splitwiser">

    <link rel="icon" type="image/png" href="icons/icon-96x96.png" sizes="96x96" />
    <link rel="icon" type="image/png" href="icons/icon-192x192.png" sizes="192x192" />
    <link rel="icon" type="image/png" href="icons/icon-512x512.png" sizes="512x512" />

    <link rel="icon" type="image/svg+xml" href="favicon.svg" />
    <link rel="shortcut icon" href="favicon.ico" />
    <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png" />

    <!-- Theme color - should match --bg-success in CSS variables -->
    <meta name="theme-color" content="#16a34a">
    <meta name="msapplication-TileColor" content="#16a34a">
    <style>
        :root {
            --font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Fira Code', 'Droid Sans Mono', 'Source Code Pro', 'Consolas', 'Roboto Mono', 'Courier New', monospace;
            --bg-primary: #ede7dc;
            --bg-secondary: #ffffff;
            --bg-tertiary: #f5f2ed;
            --text-primary: #1c1917;
            --text-secondary: #44403c;
            --text-muted: #78716c;
            --text-settlements: #c2410c;
            --text-expenses: #16a34a;
            --text-success: #ffffff;
            --bg-success: #16a34a;
            --shadow-success: rgba(22, 163, 74, 0.3);
            --bg-button-primary: #16a34a;
            --bg-button-primary-hover: #22c55e;
            --text-button-primary: #ffffff;
            --bg-button-secondary: rgba(0, 0, 0, 0.1);
            --bg-button-secondary-hover: rgba(0, 0, 0, 0.2);
            --text-button-secondary: #1c1917;
            --bg-button-settle: #c2410c;
            --bg-button-settle-hover: #ea580c;
            --text-button-settle: #ffffff;
            --border-primary: #ede7dc;
            --border-focus: #16a34a;
            --border-expenses: #16a34a;
            --border-settlements: #f97316;
            --bg-error: #fee;
            --text-error: #c53030;
            --border-error: #fc8181;
            --bg-code: #f7f7f7;
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg-primary: #0c0a09;
                --bg-secondary: #1c1917;
                --bg-tertiary: #292524;
                --text-primary: #fafaf9;
                --text-secondary: #d6d3d1;
                --text-muted: #a8a29e;
                --text-settlements: #f97316;
                --text-expenses: #16a34a;
                --text-success: #000000;
                --bg-success: #22c55e;
                --shadow-success: rgba(34, 197, 94, 0.3);
                --bg-button-primary: #22c55e;
                --bg-button-primary-hover: #86efac;
                --text-button-primary: #000000;
                --bg-button-secondary: rgba(255, 255, 255, 0.2);
                --bg-button-secondary-hover: rgba(255, 255, 255, 0.5);
                --text-button-secondary: #fafaf9;
                --bg-button-settle: #f97316;
                --bg-button-settle-hover: #fb923c;
                --text-button-settle: #000000;
                --border-primary: #44403c;
                --border-focus: #22c55e;
                --border-expenses: #16a34a;
                --border-settlements: #f97316;
                --bg-error: #2d1b1b;
                --text-error: #fc8181;
                --border-error: #c53030;
                --bg-code: #2d2d2d;
            }
        }

        body {
            font-family: var(--font-family);
            font-size: 14px;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            padding-bottom: 150px;
            background: var(--bg-primary);
            line-height: 1.6;
            color: var(--text-primary);
            transition: background-color 0.2s, color 0.2s;
        }

        h1 {
            text-align: center;
            color: var(--text-primary);
            margin-bottom: 30px;
            font-weight: 600;
        }

        textarea {
            width: 100%;
            min-height: 300px;
            max-height: 60vh;
            padding: 15px;
            border: 2px solid var(--border-primary);
            border-radius: 8px;
            font-family: var(--font-family);
            font-size: 16px;
            resize: none;
            box-sizing: border-box;
            background: var(--bg-secondary);
            color: var(--text-primary);
            transition: border-color 0.2s, background-color 0.2s, color 0.2s;
            overflow-y: auto;
        }

        textarea:focus {
            outline: none;
            border-color: var(--border-focus);
        }

        .results {
            margin-top: 20px;
            border-radius: 8px;
            border: 0;
            overflow: hidden;
            transition: background-color 0.2s, border-color 0.2s;
            text-wrap: balance;
        }

        .summary {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0;
            padding: 10px 16px;
            color: var(--text-primary);
            background: var(--bg-tertiary);
            border-left: 4px solid var(--border-primary);
            transition: background-color 0.2s;
            flex-wrap: wrap;
            gap: 8px;
            width: 100%;
            box-sizing: border-box;
            border-bottom: 1px solid var(--border-primary);
        }

        .summary:last-of-type {
            border-bottom: none;
        }

        .summary .label {
            flex: 2 1 auto;
            white-space: balance;
        }

        .summary .total {
            text-align: right;
            line-height: 1.3;
        }

        .expenses-summary {
            border-left: 4px solid var(--border-expenses);
        }

        .settlements-summary {
            border-left: 4px solid var(--border-settlements);
        }
        .settlements-summary .label {
            margin-right: 8px;
        }

        .expenses-total {
            color: var(--text-expenses);
        }
        .settlements-total {
            color: var(--text-settlements);
        }

        .expenses-total, .settlements-total {
            font-size: 1.1rem;
            font-weight: bold;
        }

        button {
            font-family: var(--font-family);
            font-size: 16px;
            background: var(--bg-button-primary);
            color: var(--text-button-primary);
            border: none;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
        }

        button:hover {
            background: var(--bg-button-primary-hover);
            transform: translateY(-1px);
        }

        button:active {
            transform: translateY(0);
        }

        .actions {
            margin-top: 30px;
            display: flex;
            gap: 15px;
            justify-content: center;
        }

        .copy-button {
            padding: 12px 24px;
            border-radius: 8px;
            flex: 1;
            max-width: 200px;
        }

        .reset-button {
            padding: 12px 24px;
            border-radius: 8px;
            flex: 1;
            max-width: 200px;
            background: var(--bg-button-secondary);
            color: var(--text-button-secondary);
            border: 1px solid var(--border-primary);
        }

        .reset-button:hover {
            background: var(--bg-button-secondary-hover);
        }

        .reset-button:active {
            background: var(--bg-button-secondary-hover);
        }

        .copy-button.copied {
            background: var(--bg-success);
            color: var(--text-success);
        }

        .settle-button {
            padding: 6px 12px;
            border-radius: 4px;
            background: var(--bg-button-settle);
            color: var(--text-button-settle);
        }

        .settle-button:hover {
            background: var(--bg-button-settle-hover);
        }

        .settle-button.settled {
            background: var(--bg-success);
            color: var(--text-success);
            cursor: default;
        }

        .settlements-summary.settlement-success {
            background: var(--bg-success);
            color: var(--text-success);
            transform: scale(1.02);
            box-shadow: 0 2px 8px var(--shadow-success);
        }

        .settlements-summary.settlement-success .label {
            color: var(--text-success);
            text-align: center;
            font-weight: bold;
        }

        .settlements-summary.settlement-success .settle-button {
            background: var(--bg-button-secondary-hover);
            color: var(--text-success);
            cursor: default;
        }

        .settlements-summary.all-settled-up {
            color: var(--text-muted);
            font-style: italic;
        }

        .validation-warning {
            background: var(--bg-error);
            color: var(--text-error);
            border: 1px solid var(--border-error);
            border-radius: 8px;
            padding: 12px;
            margin: 10px 0;
            line-height: 1.4;
        }

        .validation-warning .warning-line {
            background: var(--bg-code);
            padding: 4px 8px;
            border-radius: 4px;
            margin: 4px 0;
            font-family: monospace;
            border-left: 3px solid var(--border-error);
        }

        /* Slide animations */
        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-15px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }



        .slide-in {
            opacity: 0;
            transform: translateY(-15px);
            animation: slideDown 0.3s ease-out forwards;
        }



        @media (max-width: 768px) {
            .settle-text {
                display: none;
            }

            .actions {
                flex-direction: column;
            }

            .copy-button,
            .reset-button {
                max-width: none;
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <textarea id="expenseInput" placeholder="ADICIONE DESPESAS NO FORMATO:

David
18,11 Pedágio (por padrão dividido entre todos)
1.200,00 Hotel (pode usar ponto ou vírgula)

Ana 3 (grupo de três, terá parte maior na divisão)
45 Restaurante (não precisa colocar centavos)
23 Lanche - David, Ana (dividido somente entre David e Ana)

Cristy
50 (descrição opcional)
125,75 Compras - C,A (pode usar somente iniciais)"
onblur="handleBlur()"
onpaste="setTimeout(() => { autoExpandTextarea(this); }, 0)"></textarea>

    <div id="validationWarning" class="validation-warning" style="display: none;">
        <div id="validationContent"></div>
    </div>

    <div class="results" id="expenses-results">
    </div>

    <div class="results" id="settlements-results">
    </div>

    <div class="actions">
        <button class="copy-button" id="copyButton" onclick="copyToClipboard()" style="display: none;">COPIAR RESUMO</button>
        <button class="reset-button" id="resetButton" onclick="resetData()" style="display: none;">LIMPAR</button>
    </div>

    <!-- Web Component Templates -->
    <template id="expenses-template">
        <div class="summary expenses-summary">
            <span class="label"></span>
            <span class="total"></span>
        </div>
    </template>

    <template id="settlement-template">
        <div class="summary settlements-summary">
            <span class="label"></span>
            <button class="settle-button">✓<span class="settle-text"> ACERTADO</span></button>
        </div>
    </template>



    <template id="validation-warning-template">
        <div class="warning-line"></div>
    </template>

    <script>
        // Global error handler
        window.onerror = function(message, source, lineno, colno, error) {
            console.error('Global error caught:', message, error);
            const expensesDiv = document.getElementById('expenses-results');
            const settlementsDiv = document.getElementById('settlements-results');
            if (expensesDiv) {
                expensesDiv.innerHTML = '';
            }
            if (settlementsDiv) {
                settlementsDiv.innerHTML = '';
            }
            return true;
        };

        // Promise rejection handler
        window.addEventListener('unhandledrejection', function(event) {
            console.error('Unhandled promise rejection:', event.reason);
            const expensesDiv = document.getElementById('expenses-results');
            const settlementsDiv = document.getElementById('settlements-results');
            if (expensesDiv) {
                expensesDiv.innerHTML = '';
            }
            if (settlementsDiv) {
                settlementsDiv.innerHTML = '';
            }
            event.preventDefault();
        });

        let debounceTimer;
        let currentPeopleData = {};
        let currentSettlements = [];
        let currentTransactions = [];
        let previousResultsHTML = '';
        let previousPeopleCount = 0;
        let previousSettlementCount = 0;
        let previousPeopleNames = [];
        let previousSettlementKeys = [];
        let isSettling = false;

        // Utility function to reset global state variables
        function resetGlobalState() {
            currentPeopleData = {};
            currentSettlements = [];
            currentTransactions = [];
            previousResultsHTML = '';
            previousPeopleCount = 0;
            previousSettlementCount = 0;
            previousPeopleNames = [];
            previousSettlementKeys = [];
            isSettling = false;
        }

        // Constants for configuration and magic values
        const CONSTANTS = {
            // Timing values (in milliseconds)
            DEBOUNCE_TIMEOUT: 300,
            COPY_SUCCESS_TIMEOUT: 2000,
            SETTLEMENT_SUCCESS_TIMEOUT: 800,

            // Animation delays (in milliseconds)
            PERSON_ANIMATION_DELAY: 50,
            SETTLEMENT_ANIMATION_DELAY: 75,
            TOTAL_ROW_EXTRA_DELAY: 100,

            // Transaction types
            TRANSACTION_TYPES: {
                EXPENSE: 'expense',
                SETTLEMENT: 'settlement'
            },

            // CSS classes
            CSS_CLASSES: {
                SLIDE_IN: 'slide-in',
                COPIED: 'copied',
                SETTLEMENT_SUCCESS: 'settlement-success'
            },

            // Messages
            MESSAGES: {
                PROCESSING_ERROR: 'Erro ao processar os dados. Verifique o formato.',
                SETTLED_TEXT: 'ACERTADO',
                COPY_SUCCESS: 'COPIADO ✓',
                NOTHING_TO_COPY: 'Nada para copiar. Adicione alguns gastos primeiro.',
                COPY_ERROR: 'Erro ao copiar. Tente novamente.',
                RESET_CONFIRM: 'Tem certeza que deseja limpar todos os dados? Esta ação não pode ser desfeita.',
                RESET_ERROR: 'Erro ao limpar os dados. Tente novamente.',
                EXPENSES: 'Gastos',
                SETTLEMENTS: 'Acertos',
                TRANSACTIONS_SECTION: '*PAGAMENTOS*',
                EXPENSES_SECTION: '*GASTOS*',
                SETTLEMENTS_SECTION: '*ACERTOS*',

                OWES_TEMPLATE: '{fromName} deve {amount} para {toName}',
                SETTLEMENT_WORD: 'Acerto',
                PERSON_NOT_FOUND: 'não corresponde a nenhuma pessoa listada',
                AMBIGUOUS_PERSON_TEMPLATE: '"{personRef}" é ambíguo - pode se referir a: {matchingNames}',
                PERSON_NOT_FOUND_TEMPLATE: '"{personRef}" {errorMessage}',
                PAYMENT_LINE_TEMPLATE: '-{amount} {settlementWord} - {toName}',
                PERSON_WITH_PARTS_TEMPLATE: '{displayName} ({parts})',
                EXPENSE_WITH_PARTICIPANTS_TEMPLATE: '{description} - {participants}',
                COPY_MANUAL_SELECT: 'Não foi possível copiar automaticamente. Selecione e copie manualmente.',
                COPY_MANUAL_FALLBACK: 'Erro ao copiar. Tente selecionar e copiar manualmente.',
                SETTLEMENT_ERROR: 'Erro ao processar acerto. Tente novamente.',
                ALL_SETTLED: 'Tudo acertado!',
                NOTHING_TO_SETTLE: 'Nada para acertar!'
            },



            // LocalStorage
            STORAGE_KEY: 'expenseInputData',

            // Number formatting
            DEFAULT_LOCALE: 'pt-BR',
        };

        // Centralized error handling utility
        const ErrorHandler = {
            // Handle UI errors with user-friendly messages
            handleUIError(error, userMessage, showAlert = true) {
                console.error('UI Error:', error);
                if (showAlert) {
                    alert(userMessage);
                }
                // Reset UI state on critical errors
                setButtonVisibility(false);
                resetGlobalState();
            },

            // Handle processing errors with fallback UI
            handleProcessingError(error, fallbackHTML = null) {
                console.error('Processing Error:', error);
                const expensesDiv = document.getElementById('expenses-results');
                const settlementsDiv = document.getElementById('settlements-results');
                expensesDiv.innerHTML = '';
                settlementsDiv.innerHTML = '';
                setButtonVisibility(false);
                resetGlobalState();
            },

            // Handle validation errors
            handleValidationError(error, warnings = []) {
                console.error('Validation Error:', error);
                displayValidationWarnings(warnings);
                setButtonVisibility(false);
            },

            // Log warnings without stopping execution
            logWarning(message, data = null) {
                console.warn('Warning:', message, data);
            }
        };

        // Utility function to manage button visibility
        function setButtonVisibility(show) {
            const copyButton = document.getElementById('copyButton');
            const resetButton = document.getElementById('resetButton');
            const display = show ? 'block' : 'none';

            copyButton.style.display = display;
            resetButton.style.display = display;
        }

        // Utility function to generate person summary HTML
        function generatePersonSummaryHTML(name, fairShare, displayName, parts, shouldAnimate, animationDelay) {
            const template = document.getElementById('expenses-template');
            const clone = template.content.cloneNode(true);

            const animationClass = shouldAnimate ? 'slide-in' : '';

            const wrapper = clone.querySelector('.summary');
            wrapper.className = `summary expenses-summary ${animationClass}`;

            if (shouldAnimate) {
                wrapper.style.animationDelay = `${animationDelay}ms`;
            }

            clone.querySelector('.label').textContent = escapeHtml(formatPersonWithParts(displayName, parts));
            clone.querySelector('.total').textContent = formatNumber(fairShare);

            // Create a temporary div to get the outerHTML
            const tempDiv = document.createElement('div');
            tempDiv.appendChild(clone);
            return tempDiv.innerHTML;
        }

        // Utility function to generate settlement HTML
        function generateSettlementHTML(settlement, index, shouldAnimate, animationDelay, people) {
            const fromPerson = people[settlement.from];
            const toPerson = people[settlement.to];
            const fromName = fromPerson ? fromPerson.displayName : settlement.from;
            const toName = toPerson ? toPerson.displayName : settlement.to;

            const template = document.getElementById('settlement-template');
            const clone = template.content.cloneNode(true);

            const animationClass = shouldAnimate ? 'slide-in' : '';

            const wrapper = clone.querySelector('.settlements-summary');
            wrapper.className = `summary settlements-summary ${animationClass}`;
            wrapper.dataset.settlementIndex = index;

            if (shouldAnimate) {
                wrapper.style.animationDelay = `${animationDelay}ms`;
            }

            clone.querySelector('.label').textContent = formatTemplate(
                CONSTANTS.MESSAGES.OWES_TEMPLATE,
                {
                    fromName: escapeHtml(fromName),
                    amount: formatNumber(settlement.amount),
                    toName: escapeHtml(toName)
                }
            );

            // Add inline onclick handler to the settle button
            const settleButton = clone.querySelector('.settle-button');
            settleButton.setAttribute('onclick', `settlePayment(${index})`);
            settleButton.setAttribute('onmousedown', 'event.preventDefault()');

            // Create a temporary div to get the outerHTML
            const tempDiv = document.createElement('div');
            tempDiv.appendChild(clone);
            return tempDiv.innerHTML;
        }

        // Utility function to generate no-data message HTML using template


        // Utility function to generate validation warning HTML using template
        function generateValidationWarningHTML(errorMessage) {
            const template = document.getElementById('validation-warning-template');
            const clone = template.content.cloneNode(true);

            clone.querySelector('.warning-line').textContent = errorMessage;

            // Create a temporary div to get the outerHTML
            const tempDiv = document.createElement('div');
            tempDiv.appendChild(clone);
            return tempDiv.innerHTML;
        }

        function findPersonByNameOrInitial(nameOrInitial, allNames, personData) {
            // First try exact match with original names
            if (allNames.includes(nameOrInitial)) {
                return nameOrInitial;
            }

            // Then try partial match from the beginning with original names
            let matches = allNames.filter(name =>
                name.toLowerCase().startsWith(nameOrInitial.toLowerCase().trim())
            );

            if (matches.length === 1) {
                return matches[0];
            }

            // Try matching against display names
            matches = allNames.filter(name => {
                const personInfo = personData[name];
                if (personInfo) {
                    return personInfo.displayName.toLowerCase().startsWith(nameOrInitial.toLowerCase().trim());
                }
                return false;
            });

            return matches.length === 1 ? matches[0] : null;
        }

        function parseTransaction(expenseLine, allNames, personData) {
            // Look for pattern: amount description - person1, person2, person3 (or single person for settlements)
            const transactionMatch = expenseLine.match(/^(-?\d+(?:[.,]\d+)*(?:[.,]\d{1,2})?)(.+?)\s*-\s*(.+)$/);

            if (transactionMatch) {
                const amount = parseNumber(transactionMatch[1]);
                const description = transactionMatch[2].trim();
                const peopleStr = transactionMatch[3].trim();

                if (amount < 0) {
                    // Negative amount: settlement to a single person
                    const resolvedPerson = findPersonByNameOrInitial(peopleStr, allNames, personData);
                    if (resolvedPerson && !isNaN(amount)) {
                        return {
                            type: CONSTANTS.TRANSACTION_TYPES.SETTLEMENT,
                            amount: Math.abs(amount),
                            description: description,
                            settleTo: resolvedPerson
                        };
                    }
                } else {
                    // Positive amount: expense
                    const peopleNames = peopleStr.split(',').map(p => p.trim());
                    const resolvedPeople = [];

                    for (const personRef of peopleNames) {
                        const resolvedPerson = findPersonByNameOrInitial(personRef, allNames, personData);
                        if (resolvedPerson) {
                            resolvedPeople.push(resolvedPerson);
                        }
                    }

                    if (!isNaN(amount) && amount >= 0 && resolvedPeople.length > 0) {
                        return {
                            type: CONSTANTS.TRANSACTION_TYPES.EXPENSE,
                            amount: amount,
                            description: description,
                            sharedWith: resolvedPeople
                        };
                    }
                }
            }

            return null;
        }

        function parseNumber(numStr) {
            try {
                numStr = numStr.trim();

                // Check for negative sign
                const isNegative = numStr.startsWith('-');
                if (isNegative) {
                    numStr = numStr.substring(1).trim();
                }

                // Handle simple integers
                if (/^\d+$/.test(numStr)) {
                    return isNegative ? -parseFloat(numStr) : parseFloat(numStr);
                }

                // Remove any non-digit, non-comma, non-dot characters
                const cleaned = numStr.replace(/[^\d.,]/g, '');
                if (!cleaned) return NaN;

                const lastDot = cleaned.lastIndexOf('.');
                const lastComma = cleaned.lastIndexOf(',');

                // No separators
                if (lastDot === -1 && lastComma === -1) {
                    const result = parseFloat(cleaned);
                    return isNegative ? -result : result;
                }

                // Only dots or only commas
                if (lastComma === -1) {
                    // Only dots: could be US format (1,234.56) or thousands (1.234)
                    const parts = cleaned.split('.');
                    const lastPart = parts[parts.length - 1];
                    if (lastPart.length <= 2 && parts.length >= 2) {
                        // Likely decimal: 1.234.56 -> 1234.56
                        const result = parseFloat(parts.slice(0, -1).join('') + '.' + lastPart);
                        return isNegative ? -result : result;
                    } else {
                        // Likely thousands: 1.234 -> 1234
                        const result = parseFloat(cleaned.replace(/\./g, ''));
                        return isNegative ? -result : result;
                    }
                }

                if (lastDot === -1) {
                    // Only commas: could be European format (1.234,56) or thousands (1,234)
                    const parts = cleaned.split(',');
                    const lastPart = parts[parts.length - 1];
                    if (lastPart.length <= 2 && parts.length >= 2) {
                        // Likely decimal: 123,45 or 1.234,56
                        const result = parseFloat(cleaned.replace(/\./g, '').replace(',', '.'));
                        return isNegative ? -result : result;
                    } else {
                        // Likely thousands: 1,234 -> 1234
                        const result = parseFloat(cleaned.replace(/,/g, ''));
                        return isNegative ? -result : result;
                    }
                }

                // Both separators present
                if (lastDot > lastComma) {
                    // Dot comes last: assume US format (1,234.56)
                    const afterDot = cleaned.substring(lastDot + 1);
                    if (afterDot.length <= 2) {
                        const result = parseFloat(cleaned.replace(/,/g, ''));
                        return isNegative ? -result : result;
                    }
                } else {
                    // Comma comes last: assume European format (1.234,56)
                    const afterComma = cleaned.substring(lastComma + 1);
                    if (afterComma.length <= 2) {
                        const result = parseFloat(cleaned.replace(/\./g, '').replace(',', '.'));
                        return isNegative ? -result : result;
                    }
                }

                // Fallback: remove all separators except the last one
                const allSeparators = [...cleaned.matchAll(/[.,]/g)];
                if (allSeparators.length > 0) {
                    const lastSeparator = allSeparators[allSeparators.length - 1];
                    const beforeLast = cleaned.substring(0, lastSeparator.index);
                    const afterLast = cleaned.substring(lastSeparator.index + 1);

                    if (afterLast.length <= 2) {
                        // Treat as decimal
                        const cleanBefore = beforeLast.replace(/[.,]/g, '');
                        const result = parseFloat(cleanBefore + '.' + afterLast);
                        return isNegative ? -result : result;
                    }
                }

                const result = parseFloat(cleaned.replace(/[.,]/g, ''));
                return isNegative ? -result : result;
            } catch (error) {
                console.error('Error parsing number:', numStr, error);
                return NaN;
            }
        }

        function formatNumber(amount) {
            try {
                // Prevent negative zero display
                if (amount === 0 || Math.abs(amount) < 0.005) {
                    amount = 0;
                }

                // Use browser's locale for number formatting
                const locale = navigator.language || CONSTANTS.DEFAULT_LOCALE;
                return amount.toLocaleString(locale, {
                    minimumFractionDigits: 2,
                    maximumFractionDigits: 2
                });
            } catch (error) {
                console.error('Error formatting number:', error);
                // Fallback to fixed decimal if locale formatting fails
                // Also handle negative zero in fallback
                if (amount === 0 || Math.abs(amount) < 0.005) {
                    amount = 0;
                }
                return amount.toFixed(2);
            }
        }

        // Safely escape HTML characters in user input to prevent HTML injection
        // This function handles characters like <, >, &, and quotes
        function escapeHtml(text) {
            if (text == null || text === undefined) {
                return '';
            }
            const div = document.createElement('div');
            div.textContent = String(text);
            return div.innerHTML;
        }

        // Format template strings with placeholder replacements
        // Supports placeholders like {name}, {amount}, etc.
        function formatTemplate(template, replacements) {
            if (!template || typeof template !== 'string') {
                return '';
            }

            let result = template;
            for (const [key, value] of Object.entries(replacements || {})) {
                const placeholder = `{${key}}`;
                result = result.replace(new RegExp(placeholder.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g'), String(value || ''));
            }
            return result;
        }

        // Helper function to format person name with parts
        function formatPersonWithParts(displayName, parts) {
            if (parts > 1) {
                return formatTemplate(CONSTANTS.MESSAGES.PERSON_WITH_PARTS_TEMPLATE, {
                    displayName: displayName,
                    parts: parts
                });
            }
            return displayName;
        }

        function validateExpenses(text) {
            const lines = text.split('\n').map(line => line.trim());
            const warnings = [];
            const people = [];
            const personData = {};

            // First pass: collect all person names
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                if (line === '') continue;

                const expenseMatch = line.match(/^(\d+(?:[.,]\d+)*(?:[.,]\d{1,2})?)/);
                if (!expenseMatch && line.length > 0) {
                    people.push(line);

                    // Parse person info for display name
                    const numberMatch = line.match(/(\d+)/);
                    let displayName = line;
                    if (numberMatch) {
                        displayName = line
                            .replace(/\s*\(\s*\d+\s*\)\s*/g, ' ')
                            .replace(/\s*-\s*\d+\s*/g, ' ')
                            .replace(/\s+\d+\s*$/g, '')
                            .replace(/^\s*\d+\s+/g, '')
                            .replace(/\s+/g, ' ')
                            .trim();
                    }
                    if (!displayName) {
                        displayName = line.replace(/\d+/g, '').trim() || line;
                    }

                    personData[line] = { displayName, originalName: line };
                }
            }

            // Second pass: check for ambiguous references in expenses
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                if (line === '') continue;

                const sharedMatch = line.match(/^(\d+(?:[.,]\d+)*(?:[.,]\d{1,2})?)(.+?)\s*-\s*(.+)$/);
                if (sharedMatch) {
                    const peopleStr = sharedMatch[3].trim();
                    const peopleRefs = peopleStr.split(',').map(p => p.trim());

                    for (const personRef of peopleRefs) {
                        // Skip empty references (e.g., from trailing commas like "D,")
                        if (personRef.trim() === '') {
                            continue;
                        }

                        // Find potential matches
                        const exactMatches = people.filter(name => name === personRef);
                        const partialMatches = people.filter(name =>
                            name.toLowerCase().startsWith(personRef.toLowerCase())
                        );
                        const displayMatches = people.filter(name => {
                            const info = personData[name];
                            return info && info.displayName.toLowerCase().startsWith(personRef.toLowerCase());
                        });

                        // Check for ambiguity
                        const allMatches = [...new Set([...exactMatches, ...partialMatches, ...displayMatches])];

                        if (allMatches.length > 1) {
                            const matchingNames = allMatches.map(name => personData[name].displayName).join(', ');
                            warnings.push({
                                line: i + 1,
                                text: line,
                                error: formatTemplate(CONSTANTS.MESSAGES.AMBIGUOUS_PERSON_TEMPLATE, {
                                    personRef: personRef,
                                    matchingNames: matchingNames
                                })
                            });
                        } else if (allMatches.length === 0) {
                            warnings.push({
                                line: i + 1,
                                text: line,
                                error: formatTemplate(CONSTANTS.MESSAGES.PERSON_NOT_FOUND_TEMPLATE, {
                                    personRef: personRef,
                                    errorMessage: CONSTANTS.MESSAGES.PERSON_NOT_FOUND
                                })
                            });
                        }
                    }
                }
            }

            return warnings;
        }

        function parseExpenses(text) {
            try {
                const lines = text.split('\n').map(line => line.trim());
                const people = {};
                const transactions = [];
                let currentPerson = null;

                // Helper function to extract name and parts from a person string
                function parsePersonName(personString) {
                    // Look for numbers in the string (e.g., "David 3", "David (3)", "David-3", etc.)
                    const numberMatch = personString.match(/(\d+)/);
                    const parts = numberMatch ? parseInt(numberMatch[1]) : 1;

                    // Remove the number and any surrounding punctuation/spaces for display name
                    let displayName = personString;
                    if (numberMatch) {
                        // Remove the matched number and surrounding characters more carefully
                        displayName = personString
                            .replace(/\s*\(\s*\d+\s*\)\s*/g, ' ')  // Replace (3) with space
                            .replace(/\s*-\s*\d+\s*/g, ' ')        // Replace -3 with space
                            .replace(/\s+\d+\s*$/g, '')           // Remove trailing number
                            .replace(/^\s*\d+\s+/g, '')           // Remove leading number
                            .replace(/\s+/g, ' ')                 // Normalize multiple spaces
                            .trim();
                    }

                    // Fallback to original string if displayName is empty
                    if (!displayName) {
                        displayName = personString.replace(/\d+/g, '').trim() || personString;
                    }

                    return {
                        displayName: displayName,
                        parts: parts,
                        originalName: personString
                    };
                }

                // First pass: collect all person names with their parts
                const allNames = [];
                const personData = {};
                for (const line of lines) {
                    if (line === '') continue;

                    const expenseMatch = line.match(/^(-?\d+(?:[.,]\d+)*(?:[.,]\d{1,2})?)/);
                    const startsWithLetter = /^\s*[a-zA-ZÀ-ÿ]/i.test(line);

                    if (!expenseMatch && startsWithLetter && line.length > 0) {
                        const personInfo = parsePersonName(line);
                        allNames.push(line);
                        personData[line] = personInfo;
                    }
                }

                // Initialize people objects
                allNames.forEach(name => {
                    people[name] = {
                        expenses: [],
                        total: 0,
                        displayName: personData[name].displayName,
                        parts: personData[name].parts
                    };
                });

                // Second pass: process transactions
                for (const line of lines) {
                    if (line === '') {
                        currentPerson = null;
                        continue;
                    }

                    // Enhanced regex to capture numbers with various formats, including negative numbers
                    const expenseMatch = line.match(/^(-?\d+(?:[.,]\d+)*(?:[.,]\d{1,2})?)/);

                    if (expenseMatch && currentPerson) {
                        // Parse transaction (expense or settlement)
                        const parsedTransaction = parseTransaction(line, allNames, personData);
                        const amount = parseNumber(expenseMatch[1]);
                        const description = line.substring(expenseMatch[0].length).trim();

                        if (!isNaN(amount) && allNames.length > 0) {
                            let finalTransaction;

                            if (parsedTransaction) {
                                // Use parsed transaction details
                                finalTransaction = {
                                    ...parsedTransaction,
                                    paidBy: currentPerson
                                };
                            } else if (amount >= 0) {
                                // Default positive amounts to be split among all people
                                finalTransaction = {
                                    type: CONSTANTS.TRANSACTION_TYPES.EXPENSE,
                                    amount: amount,
                                    description: description,
                                    sharedWith: allNames,
                                    paidBy: currentPerson
                                };
                            } else {
                                // Negative amount without specific recipient - treat as simple settlement
                                finalTransaction = {
                                    type: CONSTANTS.TRANSACTION_TYPES.SETTLEMENT,
                                    amount: Math.abs(amount),
                                    description: description,
                                    paidBy: currentPerson
                                };
                            }

                            transactions.push(finalTransaction);

                            // Add to person's expenses list
                            people[currentPerson].expenses.push({
                                amount: amount,
                                description: finalTransaction.type === CONSTANTS.TRANSACTION_TYPES.EXPENSE && finalTransaction.sharedWith
                                    ? formatTemplate(CONSTANTS.MESSAGES.EXPENSE_WITH_PARTICIPANTS_TEMPLATE, {
                                        description: finalTransaction.description,
                                        participants: finalTransaction.sharedWith.join(', ')
                                    })
                                    : finalTransaction.description,
                                type: finalTransaction.type
                            });
                            people[currentPerson].total += amount;
                        }
                    } else {
                        // Check if this line could be a person's name (starts with letter)
                        const startsWithLetter = /^\s*[a-zA-ZÀ-ÿ]/i.test(line);
                        if (startsWithLetter && line.length > 0) {
                            // This is a person's name
                            currentPerson = line;
                            if (!people[currentPerson]) {
                                people[currentPerson] = {
                                    expenses: [],
                                    total: 0
                                };
                            }
                        }
                        // If line doesn't match expense format and doesn't start with letter, ignore it
                    }
                }

                return { people, transactions };
            } catch (error) {
                console.error('Error parsing expenses:', error);
                return { people: {}, transactions: [] };
            }
        }

        function calculateFairShares(names, transactions, peopleData) {
            // Calculate total amounts each person owes across all expenses
            // Now uses parts/shares for proportional division instead of equal splits
            const totalOwed = {};
            names.forEach(name => {
                totalOwed[name] = 0;
            });

            // Filter for expenses only and process them
            const expenseTransactions = transactions.filter(t =>
                t.type === CONSTANTS.TRANSACTION_TYPES.EXPENSE
            );

            expenseTransactions.forEach(transaction => {
                const { amount, sharedWith } = transaction;
                const amountCents = Math.round(amount * 100);

                // Calculate total parts for this expense
                const totalParts = sharedWith.reduce((sum, person) => {
                    const parts = peopleData[person] ? peopleData[person].parts : 1;
                    return sum + parts;
                }, 0);

                // Distribute the expense based on parts
                let distributedCents = 0;
                const distributions = [];

                sharedWith.forEach(person => {
                    const parts = peopleData[person] ? peopleData[person].parts : 1;
                    const personShareCents = Math.round((amountCents * parts) / totalParts);

                    distributions.push({ person, amount: personShareCents });
                    distributedCents += personShareCents;
                });

                // Handle any rounding difference
                const difference = amountCents - distributedCents;
                if (difference !== 0) {
                    // Add the difference to the person with the highest parts (most fair)
                    const maxPartsParticipant = sharedWith.reduce((max, person) => {
                        const parts = peopleData[person] ? peopleData[person].parts : 1;
                        const maxParts = peopleData[max] ? peopleData[max].parts : 1;
                        return parts > maxParts ? person : max;
                    });

                    const adjustmentIndex = distributions.findIndex(d => d.person === maxPartsParticipant);
                    if (adjustmentIndex !== -1) {
                        distributions[adjustmentIndex].amount += difference;
                    }
                }

                // Apply the distributions
                distributions.forEach(({ person, amount }) => {
                    totalOwed[person] += amount;
                });
            });

            // Convert cents to dollars for final fair shares
            const fairShares = {};
            names.forEach(name => {
                fairShares[name] = totalOwed[name] / 100;
            });

            return fairShares;
        }

        function calculateSettlements(people, transactions) {
            try {
                const names = Object.keys(people);
                if (names.length === 0) return [];

                const fairShares = calculateFairShares(names, transactions, people);

                // Calculate balances accounting for existing settlements
                const balances = {};
                names.forEach(name => {
                    balances[name] = 0;
                });

                // Start with what each person paid for expenses minus fair share
                names.forEach(name => {
                    // Only count expenses toward what they paid
                    const expensesPaid = people[name].expenses
                        .filter(expense => expense.type === CONSTANTS.TRANSACTION_TYPES.EXPENSE)
                        .reduce((sum, expense) => sum + expense.amount, 0);

                    const totalShouldPay = fairShares[name];
                    balances[name] = expensesPaid - totalShouldPay;
                });

                // Apply existing settlements to adjust balances
                transactions.filter(t => t.type === CONSTANTS.TRANSACTION_TYPES.SETTLEMENT).forEach(settlement => {
                    if (settlement.settleTo) {
                        // Settlement from paidBy to settleTo
                        balances[settlement.paidBy] += settlement.amount; // Payer owes less
                        balances[settlement.settleTo] -= settlement.amount; // Recipient is owed less
                    }
                });

                // Calculate remaining settlements needed
                const settlements = [];
                const debtors = names.filter(name => balances[name] < -0.01).map(name => ({
                    name,
                    amount: Math.abs(balances[name])
                })).sort((a, b) => b.amount - a.amount);

                const creditors = names.filter(name => balances[name] > 0.01).map(name => ({
                    name,
                    amount: balances[name]
                })).sort((a, b) => b.amount - a.amount);

                let i = 0, j = 0;
                while (i < debtors.length && j < creditors.length) {
                    const debtor = debtors[i];
                    const creditor = creditors[j];
                    const amount = Math.min(debtor.amount, creditor.amount);

                    if (amount > 0.01) {
                        settlements.push({
                            from: debtor.name,
                            to: creditor.name,
                            amount: amount
                        });

                        debtor.amount -= amount;
                        creditor.amount -= amount;
                    }

                    if (debtor.amount < 0.01) i++;
                    if (creditor.amount < 0.01) j++;
                }

                return settlements;
            } catch (error) {
                console.error('Error calculating settlements:', error);
                return [];
            }
        }



        function generateTextSummary() {
            try {
                const names = Object.keys(currentPeopleData);
                if (names.length === 0) return '';

                // Calculate total expenses from expense transactions only
                const totalExpenses = currentTransactions
                    .filter(t => t.type === CONSTANTS.TRANSACTION_TYPES.EXPENSE)
                    .reduce((sum, transaction) => sum + transaction.amount, 0);

                // Calculate total settlements from settlement transactions only
                const totalSettlements = currentTransactions
                    .filter(t => t.type === CONSTANTS.TRANSACTION_TYPES.SETTLEMENT)
                    .reduce((sum, transaction) => sum + transaction.amount, 0);

                // Calculate fair shares using the helper function
                const fairShares = calculateFairShares(names, currentTransactions, currentPeopleData);

                let text = '';

                // Use the already formatted input text instead of regenerating it
                const formattedInputText = formatInputText();
                if (formattedInputText) {
                    text += CONSTANTS.MESSAGES.TRANSACTIONS_SECTION + '\n';
                    text += formattedInputText + '\n';
                }

                // Add summary
                if (totalExpenses === 0) {
                    text += '\n' + CONSTANTS.MESSAGES.EXPENSES_SECTION + '\n';
                } else {
                    text += '\n' + CONSTANTS.MESSAGES.EXPENSES_SECTION + ' = ' + formatNumber(totalExpenses) + '\n';
                }
                names.forEach(name => {
                    const personTotal = currentPeopleData[name] ? currentPeopleData[name].total || 0 : 0;
                    const personShare = fairShares[name] || 0;
                    const person = currentPeopleData[name];
                    const displayName = person ? person.displayName : name;
                    const parts = person ? person.parts : 1;
                    text += `${formatPersonWithParts(displayName, parts)} = ${formatNumber(personShare)}\n`;
                });

                // Add settlements
                if (totalSettlements === 0) {
                    text += '\n' + CONSTANTS.MESSAGES.SETTLEMENTS_SECTION + '\n';
                } else {
                    text += '\n' + CONSTANTS.MESSAGES.SETTLEMENTS_SECTION + ' = ' + formatNumber(totalSettlements) + '\n';
                }
                if (totalExpenses === 0) {
                  text += CONSTANTS.MESSAGES.NOTHING_TO_SETTLE + '\n';
                } else if ( currentSettlements.length === 0) {
                    text += CONSTANTS.MESSAGES.ALL_SETTLED + '\n';
                } else {
                    currentSettlements.forEach(settlement => {
                        const fromPerson = currentPeopleData[settlement.from];
                        const toPerson = currentPeopleData[settlement.to];
                        const fromName = fromPerson ? fromPerson.displayName : settlement.from;
                        const toName = toPerson ? toPerson.displayName : settlement.to;
                        text += formatTemplate(
                            CONSTANTS.MESSAGES.OWES_TEMPLATE,
                            {
                                fromName: fromName,
                                amount: formatNumber(settlement.amount),
                                toName: toName
                            }
                        ) + '\n';
                    });
                }

                return text;
            } catch (error) {
                console.error('Error generating text summary:', error);
                return 'Erro ao gerar resumo';
            }
        }

        function applyFormattedTextToTextarea(saveToStorage = true) {
            try {
                const textarea = document.getElementById('expenseInput');
                const formattedText = formatInputText();

                if (formattedText && formattedText !== textarea.value) {
                    textarea.value = formattedText;
                    autoExpandTextarea(textarea);
                    if (saveToStorage) {
                        saveToLocalStorage();
                    }
                    return true;
                }
                return false;
            } catch (error) {
                ErrorHandler.logWarning('Apply formatted text error', error);
                return false;
            }
        }

        function handleBlur() {
            try {
                // Skip blur handling if we're in the middle of settling a payment
                if (isSettling) {
                    return;
                }

                // Cancel any pending debounced update
                clearTimeout(debounceTimer);

                // Always process current content and update results immediately
                updateResults();
                saveToLocalStorage();

                // Also apply formatting
                applyFormattedTextToTextarea(false); // Don't save again since we just saved
            } catch (error) {
                ErrorHandler.logWarning('Blur handler error', error);
            }
        }

        function formatInputText() {
            try {
                const names = Object.keys(currentPeopleData);
                if (names.length === 0) return '';

                let formattedText = '';

                // Calculate maximum width for amounts across all expenses using transactions
                let maxWidth = 0;
                currentTransactions.forEach(transaction => {
                    const width = formatNumber(transaction.amount).length;
                    if (width > maxWidth) maxWidth = width;
                });

                // Ensure minimum width for proper alignment
                if (maxWidth === 0) maxWidth = 8;

                // Format expenses by person using transaction data to reconstruct original format
                names.forEach(name => {
                    const person = currentPeopleData[name];
                    const displayName = person ? person.displayName : name;
                    const parts = person ? person.parts : 1;
                    formattedText += `${formatPersonWithParts(displayName, parts)}\n`;

                    if (person && person.expenses.length > 0) {
                        // Use transactions to reconstruct the original format
                        const processedTransactions = new Set();

                        currentTransactions.forEach(transaction => {
                            if (transaction.paidBy === name && !processedTransactions.has(transaction)) {
                                processedTransactions.add(transaction);

                                let formattedAmount, description = transaction.description || '';

                                if (transaction.type === CONSTANTS.TRANSACTION_TYPES.SETTLEMENT) {
                                    // Settlement: negative amount with recipient
                                    formattedAmount = formatNumber(-transaction.amount);
                                    if (transaction.settleTo) {
                                        const recipientData = currentPeopleData[transaction.settleTo];
                                        const recipientName = recipientData ? recipientData.displayName : transaction.settleTo;
                                        description = description ? `${description} - ${recipientName}` : `- ${recipientName}`;
                                    }
                                } else {
                                    // Expense: positive amount
                                    formattedAmount = formatNumber(transaction.amount);

                                    // Check if this expense is split with specific people (not all)
                                    const allNames = Object.keys(currentPeopleData);
                                    const isSharedWithAll = transaction.sharedWith && transaction.sharedWith.length === allNames.length && transaction.sharedWith.every(p => allNames.includes(p));

                                    // Always add participant names unless split among all people
                                    if (!isSharedWithAll && transaction.sharedWith && transaction.sharedWith.length > 0) {
                                        // Add participants to description
                                        const participants = transaction.sharedWith.map(p => {
                                            const participantData = currentPeopleData[p];
                                            return participantData ? participantData.displayName : p;
                                        }).join(', ');
                                        description = description ? `${description} - ${participants}` : `- ${participants}`;
                                    }
                                }

                                const paddedAmount = formattedAmount.padStart(maxWidth, ' ');
                                const fullDescription = description ? ` ${description}` : '';
                                formattedText += `${paddedAmount}${fullDescription}\n`;
                            }
                        });

                        // Also add any individual expenses that aren't part of transactions (like manually entered settlements)
                        person.expenses.forEach(expense => {
                            if (expense.isSettlement) {
                                const formattedAmount = formatNumber(expense.amount);
                                const paddedAmount = formattedAmount.padStart(maxWidth, ' ');
                                const fullDescription = expense.description ? ` ${expense.description}` : '';
                                formattedText += `${paddedAmount}${fullDescription}\n`;
                            }
                        });

                        formattedText += '\n';
                    }
                });

                return formattedText.trim();
            } catch (error) {
                console.error('Error formatting input text:', error);
                return '';
            }
        }

        function copyToClipboard() {
            try {
                const textSummary = generateTextSummary();

                if (!textSummary) {
                    alert(CONSTANTS.MESSAGES.NOTHING_TO_COPY);
                    return;
                }

                // Also format and update the input text
                applyFormattedTextToTextarea();

                // Try to use the modern clipboard API
                if (navigator.clipboard && window.isSecureContext) {
                    navigator.clipboard.writeText(textSummary).then(() => {
                        showCopySuccess();
                    }).catch(err => {
                        console.error('Failed to copy with clipboard API:', err);
                        fallbackCopy(textSummary);
                    });
                } else {
                    fallbackCopy(textSummary);
                }
            } catch (error) {
                ErrorHandler.handleUIError(error, CONSTANTS.MESSAGES.COPY_ERROR);
            }
        }

        function fallbackCopy(text) {
            try {
                // Fallback method using textarea
                const textArea = document.createElement('textarea');
                textArea.value = text;
                textArea.style.position = 'fixed';
                textArea.style.left = '-999999px';
                textArea.style.top = '-999999px';
                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();

                const successful = document.execCommand('copy');
                document.body.removeChild(textArea);

                if (successful) {
                    showCopySuccess();
                } else {
                    alert(CONSTANTS.MESSAGES.COPY_MANUAL_SELECT);
                }
            } catch (err) {
                console.error('Fallback copy failed:', err);
                alert(CONSTANTS.MESSAGES.COPY_MANUAL_FALLBACK);
            }
        }

        function showCopySuccess() {
            const button = document.getElementById('copyButton');
            const originalText = button.textContent;
            button.textContent = CONSTANTS.MESSAGES.COPY_SUCCESS;
            button.classList.add(CONSTANTS.CSS_CLASSES.COPIED);

            setTimeout(() => {
                button.textContent = originalText;
                button.classList.remove(CONSTANTS.CSS_CLASSES.COPIED);
            }, CONSTANTS.COPY_SUCCESS_TIMEOUT);
        }

        function displayValidationWarnings(warnings) {
            const warningDiv = document.getElementById('validationWarning');
            const contentDiv = document.getElementById('validationContent');

            if (warnings.length === 0) {
                warningDiv.style.display = 'none';
                return;
            }

            let content = '';
            warnings.forEach(warning => {
                content += generateValidationWarningHTML(warning.error);
            });

            contentDiv.innerHTML = content;
            warningDiv.style.display = 'block';
        }

        function updateResults() {
            try {
                const input = document.getElementById('expenseInput').value;
                const expensesDiv = document.getElementById('expenses-results');
                const settlementsDiv = document.getElementById('settlements-results');
                const copyButton = document.getElementById('copyButton');
                const resetButton = document.getElementById('resetButton');

                // Validate input and show warnings
                const warnings = validateExpenses(input);

                if (!input.trim()) {
                    expensesDiv.innerHTML = '';
                    settlementsDiv.innerHTML = '';
                    setButtonVisibility(false);
                    displayValidationWarnings([]);
                    resetGlobalState();
                    return;
                }

                // Display validation warnings
                displayValidationWarnings(warnings);

                // If there are critical validation errors, don't proceed with parsing
                if (warnings.length > 0) {
                    expensesDiv.innerHTML = '';
                    settlementsDiv.innerHTML = '';
                    setButtonVisibility(false);
                    resetGlobalState();
                    return;
                }

                const { people, transactions } = parseExpenses(input);
                const names = Object.keys(people);

                if (names.length === 0) {
                    expensesDiv.innerHTML = '';
                    settlementsDiv.innerHTML = '';
                    setButtonVisibility(false);
                    resetGlobalState();
                    return;
                }

                // Store current data for copying
                currentPeopleData = people;
                currentTransactions = transactions;
                currentSettlements = calculateSettlements(people, transactions);

                // Calculate total expenses from expense transactions only
                const totalExpenses = transactions
                    .filter(t => t.type === CONSTANTS.TRANSACTION_TYPES.EXPENSE)
                    .reduce((sum, transaction) => sum + transaction.amount, 0);

                // Calculate total settlements from settlement transactions only
                const totalSettlements = transactions
                    .filter(t => t.type === CONSTANTS.TRANSACTION_TYPES.SETTLEMENT)
                    .reduce((sum, transaction) => sum + transaction.amount, 0);

                // Calculate fair share amounts using the helper function
                const fairShares = calculateFairShares(names, transactions, people);

                // Create keys for comparison
                const newPeopleNames = names.slice();
                const newSettlementKeys = currentSettlements.map(s => `${s.from}->${s.to}-${s.amount}`);

                // Find removed items
                const removedPeopleNames = previousPeopleNames.filter(name => !newPeopleNames.includes(name));
                const removedSettlementKeys = previousSettlementKeys.filter(key => !newSettlementKeys.includes(key));

                // If items are being removed, animate them out first
                proceedWithUpdate();

                function proceedWithUpdate() {
                    // Determine if we should animate based on changes
                    const newPeopleCount = names.length + 2; // +2 for gastos and acertos rows
                    const newSettlementCount = currentSettlements.length;
                    const shouldAnimateNewItems = newPeopleCount > previousPeopleCount || newSettlementCount > previousSettlementCount || previousPeopleCount === 0;
                    const isFirstLoad = previousPeopleCount === 0;

                    let expensesHtml = '';
                    let settlementsHtml = '';
                    let animationDelay = 0;

                    // EXPENSES SECTION
                    // Expenses total as header
                    const totalShouldAnimate = isFirstLoad;
                    const totalAnimationClass = totalShouldAnimate ? 'slide-in' : '';
                    const totalAnimationStyle = totalShouldAnimate ? `style="animation-delay: ${animationDelay}ms"` : '';

                    expensesHtml += `
                        <div class="summary expenses-summary expenses-total ${totalAnimationClass}" ${totalAnimationStyle}>
                            <span class="label">${CONSTANTS.MESSAGES.EXPENSES}</span>
                            <span class="total">${formatNumber(totalExpenses)}</span>
                        </div>`;

                    if (totalShouldAnimate) animationDelay += CONSTANTS.TOTAL_ROW_EXTRA_DELAY;

                    // Show individual fair share expenses (excluding settlements)
                    names.forEach((name, index) => {
                        const fairShare = fairShares[name] || 0;
                        const displayName = people[name] ? people[name].displayName : name;
                        const parts = people[name] ? people[name].parts : 1;

                        const shouldAnimate = shouldAnimateNewItems && index >= previousPeopleCount - 1;
                        expensesHtml += generatePersonSummaryHTML(name, fairShare, displayName, parts, shouldAnimate, animationDelay);
                        if (shouldAnimate) animationDelay += CONSTANTS.PERSON_ANIMATION_DELAY;
                    });

                    // SETTLEMENTS SECTION
                    // Settlement total - only show if there are settlements
                    if (totalSettlements !== 0 || currentSettlements.length > 0) {
                        const settlementTotalAnimationStyle = totalShouldAnimate ? `style="animation-delay: ${animationDelay}ms"` : '';

                        settlementsHtml += `
                            <div class="summary settlements-summary settlements-total ${totalAnimationClass}" ${settlementTotalAnimationStyle}>
                                <span class="label">${CONSTANTS.MESSAGES.SETTLEMENTS}</span>
                                <span class="total">${formatNumber(Math.abs(totalSettlements))}</span>
                            </div>`;

                        if (totalShouldAnimate) animationDelay += CONSTANTS.TOTAL_ROW_EXTRA_DELAY;

                        // Show settlements
                        if (totalExpenses !== 0 && currentSettlements.length > 0) {
                            currentSettlements.forEach((settlement, index) => {
                                const shouldAnimate = shouldAnimateNewItems && index >= previousSettlementCount;
                                settlementsHtml += generateSettlementHTML(settlement, index, shouldAnimate, animationDelay, people);
                                if (shouldAnimate) animationDelay += CONSTANTS.SETTLEMENT_ANIMATION_DELAY;
                            });
                        } else if (totalSettlements !== 0 && currentSettlements.length === 0) {
                            // Show "all settled up" message when settlements total is not zero but no current settlements
                            const allSettledAnimationStyle = totalShouldAnimate ? `style="animation-delay: ${animationDelay}ms"` : '';
                            settlementsHtml += `
                                <div class="summary settlements-summary all-settled-up ${totalAnimationClass}" ${allSettledAnimationStyle}>
                                    <span class="label">${CONSTANTS.MESSAGES.ALL_SETTLED}</span>
                                </div>`;
                        }
                    }

                    expensesDiv.innerHTML = expensesHtml;
                    settlementsDiv.innerHTML = settlementsHtml;

                    // Update tracking variables
                    previousResultsHTML = expensesHtml + settlementsHtml;
                    previousPeopleCount = newPeopleCount;
                    previousSettlementCount = newSettlementCount;
                    previousPeopleNames = newPeopleNames.slice();
                    previousSettlementKeys = newSettlementKeys.slice();

                    // Show buttons when there are results
                    setButtonVisibility(true);
                }

            } catch (error) {
                ErrorHandler.handleProcessingError(error);
            }
        }

        function settlePayment(settlementIndex) {
            try {
                // Set flag to prevent blur interference
                isSettling = true;

                const settlement = currentSettlements[settlementIndex];
                if (!settlement) {
                    isSettling = false;
                    return;
                }

                const textarea = document.getElementById('expenseInput');
                const currentText = textarea.value;

                // Create the payment line in the format: "-amount Settlement to recipient"
                // Use display name consistently like in the settlement display
                const toPerson = currentPeopleData[settlement.to];
                const toDisplayName = toPerson ? toPerson.displayName : settlement.to;
                const formattedAmount = formatNumber(Number(settlement.amount));
                const settlementLine = formatTemplate(CONSTANTS.MESSAGES.PAYMENT_LINE_TEMPLATE, {
                    amount: String(formattedAmount),
                    settlementWord: CONSTANTS.MESSAGES.SETTLEMENT_WORD,
                    toName: String(toDisplayName)
                });

                // Find the payer's section and add the payment line
                const lines = currentText.split('\n');
                let payerIndex = -1;

                // Find where the payer's section starts
                for (let i = 0; i < lines.length; i++) {
                    if (lines[i].trim() === settlement.from) {
                        payerIndex = i;
                        break;
                    }
                }

                if (payerIndex !== -1) {
                    // Find the end of the payer's section (next person or end of file)
                    let insertIndex = lines.length;
                    let foundEmptyLine = false;

                    for (let i = payerIndex + 1; i < lines.length; i++) {
                        const line = lines[i].trim();

                        // If we find an empty line, mark it but continue looking
                        if (line === '') {
                            if (!foundEmptyLine) {
                                insertIndex = i;
                                foundEmptyLine = true;
                            }
                            continue;
                        }

                        // Check if this line is a person name (not an expense)
                        const expenseMatch = line.match(/^(-?\d+(?:[.,]\d+)*(?:[.,]\d{1,2})?)/);
                        if (!expenseMatch && line.length > 0) {
                            // This is a person name, insert before this line (or before the empty line if found)
                            if (!foundEmptyLine) {
                                insertIndex = i;
                            }
                            break;
                        }
                    }

                    // Insert the payment line
                    lines.splice(insertIndex, 0, settlementLine);

                    // Update the textarea
                    textarea.value = lines.join('\n');

                    // Reparse the expenses to update data structures with the new settlement
                    const { people, transactions } = parseExpenses(textarea.value);

                    if (people && transactions) {
                        currentPeopleData = people;
                        currentTransactions = transactions;

                        // Now reformat the input text with updated data
                        applyFormattedTextToTextarea(false); // Don't save to storage here, we'll save below
                    }

                    // Save to localStorage after updating textarea
                    saveToLocalStorage();

                    // Show success state with green background
                    const settlementWrapper = document.querySelector(`[data-settlement-index="${settlementIndex}"]`);
                    if (settlementWrapper) {
                        settlementWrapper.classList.add(CONSTANTS.CSS_CLASSES.SETTLEMENT_SUCCESS);

                        // Replace the settlement text with "Acertado"
                        const settlementText = settlementWrapper.querySelector('.label');
                        if (settlementText) {
                            settlementText.textContent = CONSTANTS.MESSAGES.SETTLED_TEXT;
                        }

                        // Hide the button to prevent multiple clicks
                        const button = settlementWrapper.querySelector('.settle-button');
                        if (button) {
                            button.style.display = 'none';
                        }

                        // Remove the settlement after showing success state
                        setTimeout(() => {
                            updateResults();
                            isSettling = false;
                        }, CONSTANTS.SETTLEMENT_SUCCESS_TIMEOUT);
                    }
                }
            } catch (error) {
                ErrorHandler.handleUIError(error, CONSTANTS.MESSAGES.SETTLEMENT_ERROR);
            } finally {
                // Always reset the settling flag
                setTimeout(() => {
                    isSettling = false;
                }, 100);
            }
        }


        // Add debounced event listener with error handling
        document.getElementById('expenseInput').addEventListener('input', function() {
            try {
                // Auto-expand textarea first
                autoExpandTextarea(this);

                clearTimeout(debounceTimer);
                debounceTimer = setTimeout(() => {
                    try {
                        updateResults();
                        saveToLocalStorage(); // Save to localStorage after updating results
                    } catch (error) {
                        ErrorHandler.handleProcessingError(error);
                    }
                }, CONSTANTS.DEBOUNCE_TIMEOUT);
            } catch (error) {
                ErrorHandler.logWarning('Input handler error', error);
            }
        });


        // Initial calculation with error handling
        try {
            updateResults();
        } catch (error) {
            ErrorHandler.handleProcessingError(error);
        }
        // localStorage functions
        function resetData() {
            const confirmReset = confirm(CONSTANTS.MESSAGES.RESET_CONFIRM);

            if (confirmReset) {
                try {
                    setButtonVisibility(false);

                    // Clear localStorage
                    localStorage.removeItem(CONSTANTS.STORAGE_KEY);

                    const textarea = document.getElementById('expenseInput');
                    textarea.value = '';
                    autoExpandTextarea(textarea);

                    resetGlobalState();
                    updateResults();

                } catch (error) {
                    ErrorHandler.handleUIError(error, CONSTANTS.MESSAGES.RESET_ERROR);
                }
            }
        }

        function saveToLocalStorage() {
            try {
                const textarea = document.getElementById('expenseInput');
                localStorage.setItem(CONSTANTS.STORAGE_KEY, textarea.value);
            } catch (error) {
                console.error('Error saving to localStorage:', error);
            }
        }

        function loadFromLocalStorage() {
            try {
                const savedData = localStorage.getItem(CONSTANTS.STORAGE_KEY);
                if (savedData) {
                    const textarea = document.getElementById('expenseInput');
                    textarea.value = savedData;

                    // Parse and reformat the loaded data
                    const { people, transactions } = parseExpenses(savedData);
                    if (people && transactions) {
                        currentPeopleData = people;
                        currentTransactions = transactions;

                        applyFormattedTextToTextarea(false); // Don't save to storage during load
                    }

                    // Auto-expand after loading content
                    autoExpandTextarea(textarea);
                    // Update results after loading
                    updateResults();
                }
            } catch (error) {
                console.error('Error loading from localStorage:', error);
            }
        }

        // Load saved data when page loads
        // Auto-expanding textarea functionality
        function autoExpandTextarea(textarea) {
            // Reset height to measure the scroll height accurately
            textarea.style.height = 'auto';

            // Detect if we're on mobile based on screen width and touch capability
            const isMobile = window.innerWidth <= 768 || ('ontouchstart' in window && window.innerWidth <= 1024);

            // Calculate available viewport height considering mobile keyboard space
            let availableHeight;
            if (isMobile) {
                // On mobile, use visual viewport if available (accounts for keyboard)
                // Otherwise fall back to a conservative estimate
                if (window.visualViewport) {
                    availableHeight = window.visualViewport.height;
                } else {
                    // Conservative fallback - assume keyboard takes up significant space
                    availableHeight = window.innerHeight * 0.6; // Assume keyboard uses ~40% of screen
                }
            } else {
                availableHeight = window.innerHeight;
            }

            // Calculate new height, ensuring it stays within min/max bounds
            const minHeight = 300; // matches min-height in CSS
            const maxHeightRatio = isMobile ? 0.4 : 0.6; // 40vh on mobile, 60vh on desktop
            const maxHeight = Math.floor(availableHeight * maxHeightRatio);
            const newHeight = Math.max(minHeight, Math.min(textarea.scrollHeight, maxHeight));

            textarea.style.height = newHeight + 'px';
        }


        // Handle window resize to recalculate max height
        window.addEventListener('resize', function() {
            const textarea = document.getElementById('expenseInput');
            if (textarea) {
                autoExpandTextarea(textarea);
            }
        });

        document.addEventListener('DOMContentLoaded', function() {
            loadFromLocalStorage();
            // Set initial height after loading
            const textarea = document.getElementById('expenseInput');
            if (textarea) {
                autoExpandTextarea(textarea);
            }
        });

    </script>
</body>
</html>
