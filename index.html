<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Splitwiser</title>

    <!-- PWA Manifest -->
    <link rel="manifest" href="manifest.json">

    <!-- iOS PWA Meta Tags -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="Splitwiser">

    <link rel="icon" type="image/png" href="icons/icon-96x96.png" sizes="96x96" />
    <link rel="icon" type="image/png" href="icons/icon-192x192.png" sizes="192x192" />
    <link rel="icon" type="image/png" href="icons/icon-512x512.png" sizes="512x512" />

    <link rel="icon" type="image/svg+xml" href="favicon.svg" />
    <link rel="shortcut icon" href="favicon.ico" />
    <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png" />

    <!-- Theme color - should match --bg-success in CSS variables -->
    <meta name="theme-color" content="#16a34a">
    <meta name="msapplication-TileColor" content="#16a34a">
    <style>
        :root {
            --font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Fira Code', 'Droid Sans Mono', 'Source Code Pro', 'Consolas', 'Roboto Mono', 'Courier New', monospace;
            --bg-primary: #ede7dc;
            --bg-secondary: #ffffff;
            --bg-tertiary: #f5f2ed;
            --text-primary: #1c1917;
            --text-secondary: #44403c;
            --text-muted: #78716c;
            --text-accent: #c2410c;
            --text-success: #ffffff;
            --bg-success: #16a34a;
            --shadow-success: rgba(22, 163, 74, 0.3);
            --bg-button-primary: #16a34a;
            --bg-button-primary-hover: #22c55e;
            --text-button-primary: #ffffff;
            --bg-button-secondary: rgba(0, 0, 0, 0.1);
            --bg-button-secondary-hover: rgba(0, 0, 0, 0.2);
            --text-button-secondary: #1c1917;
            --border-primary: #ede7dc;
            --border-accent: #f97316;
            --border-focus: #16a34a;
            --border-summary: #44403c;
            --border-total: #16a34a;
            --bg-error: #fee;
            --text-error: #c53030;
            --border-error: #fc8181;
            --bg-code: #f7f7f7;
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg-primary: #0c0a09;
                --bg-secondary: #1c1917;
                --bg-tertiary: #292524;
                --text-primary: #fafaf9;
                --text-secondary: #d6d3d1;
                --text-muted: #a8a29e;
                --text-accent: #fed7aa;
                --text-success: #000000;
                --bg-success: #22c55e;
                --shadow-success: rgba(34, 197, 94, 0.3);
                --bg-button-primary: #22c55e;
                --bg-button-primary-hover: #86efac;
                --text-button-primary: #000000;
                --bg-button-secondary: rgba(255, 255, 255, 0.2);
                --bg-button-secondary-hover: rgba(255, 255, 255, 0.5);
                --text-button-secondary: #fafaf9;
                --border-primary: #44403c;
                --border-accent: #ea580c;
                --border-focus: #22c55e;
                --border-summary: #78716c;
                --border-total: #22c55e;
                --bg-error: #2d1b1b;
                --text-error: #fc8181;
                --border-error: #c53030;
                --bg-code: #2d2d2d;
            }
        }

        body {
            font-family: var(--font-family);
            font-size: 14px;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            padding-bottom: 150px;
            background: var(--bg-primary);
            line-height: 1.6;
            color: var(--text-primary);
            transition: background-color 0.2s, color 0.2s;
        }

        h1 {
            text-align: center;
            color: var(--text-primary);
            margin-bottom: 30px;
            font-weight: 600;
        }

        textarea {
            width: 100%;
            min-height: 300px;
            max-height: 60vh;
            padding: 15px;
            border: 2px solid var(--border-primary);
            border-radius: 8px;
            font-family: var(--font-family);
            font-size: 16px;
            resize: none;
            box-sizing: border-box;
            background: var(--bg-secondary);
            color: var(--text-primary);
            transition: border-color 0.2s, background-color 0.2s, color 0.2s;
            overflow-y: auto;
        }

        textarea:focus {
            outline: none;
            border-color: var(--border-focus);
        }

        .results {
            margin-top: 20px;
            border-radius: 8px;
            border: 1px solid var(--border-primary);
            overflow: hidden;
            transition: background-color 0.2s, border-color 0.2s;
        }

        .person-summary {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0;
            padding: 12px;
            background: var(--bg-tertiary);
            border-left: 4px solid var(--border-summary);
            transition: background-color 0.2s;
            flex-wrap: wrap;
            gap: 8px;
            width: 100%;
            box-sizing: border-box;
            border-bottom: 1px solid var(--border-primary);
        }

        .person-summary:last-of-type {
            border-bottom: none;
        }

        .person-summary.total-row {
            font-weight: 600;
            border-left-color: var(--border-total);
            margin-top: 10px;
            margin-bottom: 10px;
        }

        .person-name {
            font-weight: 500;
            color: var(--text-primary);
            flex: 0 0 auto;
            white-space: nowrap;
        }

        .person-paid {
            color: var(--text-muted);
        }

        .person-total {
            color: var(--text-secondary);
            font-weight: 500;
            text-align: right;
            line-height: 1.3;
            min-width: 100px;
        }



        .settlement-wrapper {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0;
            padding: 12px;
            background: var(--bg-tertiary);
            border-left: 4px solid var(--border-accent);
            transition: background-color 0.2s;
            flex-wrap: wrap;
            gap: 8px;
            width: 100%;
            box-sizing: border-box;
            border-bottom: 1px solid var(--border-primary);
        }

        .settlement-wrapper:last-child {
            border-bottom: none;
        }

        .settlement-text {
            color: var(--text-accent);
            font-weight: 500;
            flex: 1;
        }

        .no-data {
            padding: 40px 20px;
            text-align: center;
            color: var(--text-muted);
            font-style: italic;
            width: 100%;
            box-sizing: border-box;
        }

        button {
            font-family: var(--font-family);
            font-size: 16px;
            background: var(--bg-button-primary);
            color: var(--text-button-primary);
            border: none;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
        }

        button:hover {
            background: var(--bg-button-primary-hover);
            transform: translateY(-1px);
        }

        button:active {
            transform: translateY(0);
        }

        .actions {
            margin-top: 30px;
            display: flex;
            gap: 15px;
            justify-content: center;
        }

        .copy-button {
            padding: 12px 24px;
            border-radius: 8px;
            flex: 1;
            max-width: 200px;
        }

        .reset-button {
            padding: 12px 24px;
            border-radius: 8px;
            flex: 1;
            max-width: 200px;
            background: var(--bg-button-secondary);
            color: var(--text-button-secondary);
            border: 1px solid var(--border-primary);
        }

        .reset-button:hover {
            background: var(--bg-button-secondary-hover);
        }

        .reset-button:active {
            background: var(--bg-button-secondary-hover);
        }

        .copy-button.copied {
            background: var(--bg-success);
            color: var(--text-success);
        }

        .settle-button {
            padding: 6px 12px;
            border-radius: 4px;
            margin-left: 10px;
        }

        .settle-button.settled {
            background: var(--bg-success);
            color: var(--text-success);
            cursor: default;
        }

        .settlement-wrapper.settlement-success {
            background: var(--bg-success);
            color: var(--text-success);
            transform: scale(1.02);
            box-shadow: 0 2px 8px var(--shadow-success);
        }

        .settlement-wrapper.settlement-success .settlement-text {
            color: var(--text-success);
        }

        .settlement-wrapper.settlement-success .settle-button {
            background: var(--bg-button-secondary-hover);
            color: var(--text-success);
            cursor: default;
        }

        .validation-warning {
            background: var(--bg-error);
            color: var(--text-error);
            border: 1px solid var(--border-error);
            border-radius: 8px;
            padding: 12px;
            margin: 10px 0;
            line-height: 1.4;
        }

        .validation-warning .warning-line {
            background: var(--bg-code);
            padding: 4px 8px;
            border-radius: 4px;
            margin: 4px 0;
            font-family: monospace;
            border-left: 3px solid var(--border-error);
        }



        @media (max-width: 768px) {
            .settle-text {
                display: none;
            }

            .actions {
                flex-direction: column;
            }

            .copy-button,
            .reset-button {
                max-width: none;
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <textarea id="expenseInput" placeholder="David
18,11 Pedágio (por padrão dividido entre todos)
1.200,00 Hotel (pode usar ponto ou vírgula)

Ana 2 (grupo de duas pessoas, terá parte maior na divisão)
45 Restaurante (não precisa colocar centavos)
23 Lanche - David, Ana (dividido entre David e Ana)

Cristy
50 (descrição opcional)
125,75 Compras - C,A (pode usar somente iniciais)"></textarea>

    <div id="validationWarning" class="validation-warning" style="display: none;">
        <div id="validationContent"></div>
    </div>

    <div class="results" id="results">
        <div class="no-data"></div>
    </div>

    <div class="actions">
        <button class="copy-button" id="copyButton" onclick="copyToClipboard()" style="display: none;">COPIAR RESUMO</button>
        <button class="reset-button" id="resetButton" onclick="resetData()">LIMPAR</button>
    </div>

    <script>
        // Global error handler
        window.onerror = function(message, source, lineno, colno, error) {
            console.error('Global error caught:', message, error);
            const resultsDiv = document.getElementById('results');
            if (resultsDiv) {
                resultsDiv.innerHTML = '<div class="no-data">Erro: Por favor recarregue a página e tente novamente.</div>';
            }
            return true;
        };

        // Promise rejection handler
        window.addEventListener('unhandledrejection', function(event) {
            console.error('Unhandled promise rejection:', event.reason);
            const resultsDiv = document.getElementById('results');
            if (resultsDiv) {
                resultsDiv.innerHTML = '<div class="no-data">Erro: Por favor recarregue a página e tente novamente.</div>';
            }
            event.preventDefault();
        });

        let debounceTimer;
        let currentPeopleData = {};
        let currentSettlements = [];
        let currentSharedExpenses = [];

        function findPersonByNameOrInitial(nameOrInitial, allNames, personData) {
            // First try exact match with original names
            if (allNames.includes(nameOrInitial)) {
                return nameOrInitial;
            }

            // Then try partial match from the beginning with original names
            let matches = allNames.filter(name =>
                name.toLowerCase().startsWith(nameOrInitial.toLowerCase().trim())
            );

            if (matches.length === 1) {
                return matches[0];
            }

            // Try matching against display names
            matches = allNames.filter(name => {
                const personInfo = personData[name];
                if (personInfo) {
                    return personInfo.displayName.toLowerCase().startsWith(nameOrInitial.toLowerCase().trim());
                }
                return false;
            });

            return matches.length === 1 ? matches[0] : null;
        }

        function parseSharedExpense(expenseLine, allNames, personData) {
            // Look for pattern: amount description - person1, person2, person3
            const sharedMatch = expenseLine.match(/^(\d+(?:[.,]\d+)*(?:[.,]\d{1,2})?)(.+?)\s*-\s*(.+)$/);

            if (sharedMatch) {
                const amount = parseNumber(sharedMatch[1]);
                const description = sharedMatch[2].trim();
                const peopleStr = sharedMatch[3].trim();

                // Parse the people list
                const peopleNames = peopleStr.split(',').map(p => p.trim());
                const resolvedPeople = [];

                for (const personRef of peopleNames) {
                    const resolvedPerson = findPersonByNameOrInitial(personRef, allNames, personData);
                    if (resolvedPerson) {
                        resolvedPeople.push(resolvedPerson);
                    }
                }

                if (!isNaN(amount) && amount >= 0 && resolvedPeople.length > 0) {
                    return {
                        amount: amount,
                        description: description,
                        sharedWith: resolvedPeople
                    };
                }
            }

            return null;
        }

        function parseNumber(numStr) {
            try {
                // Remove any leading/trailing whitespace
                numStr = numStr.trim();

                // If it's a simple integer with no separators
                if (/^\d+$/.test(numStr)) {
                    return parseFloat(numStr);
                }

                // Count dots and commas to determine format
                const dotCount = (numStr.match(/\./g) || []).length;
                const commaCount = (numStr.match(/,/g) || []).length;

                // If no separators at all, just parse as is
                if (dotCount === 0 && commaCount === 0) {
                    return parseFloat(numStr);
                }

                // Patterns for different formats
                const patterns = {
                    // European format: 1.234.567,89 or 1.234,89 or 123,89
                    european: /^\d{1,3}(?:\.\d{3})*,\d{1,2}$/,
                    // US format: 1,234,567.89 or 1,234.89 or 123.89
                    us: /^\d{1,3}(?:,\d{3})*\.\d{1,2}$/,
                    // Simple decimal with dot: 123.45
                    simpleDot: /^\d+\.\d{1,2}$/,
                    // Simple decimal with comma: 123,45
                    simpleComma: /^\d+,\d{1,2}$/,
                    // Thousands only with dots: 1.234 or 12.345
                    thousandsDot: /^\d{1,3}(?:\.\d{3})+$/,
                    // Thousands only with commas: 1,234 or 12,345
                    thousandsComma: /^\d{1,3}(?:,\d{3})+$/
                };

                // European format (1.234.567,89)
                if (patterns.european.test(numStr)) {
                    return parseFloat(numStr.replace(/\./g, '').replace(',', '.'));
                }

                // US format (1,234,567.89)
                if (patterns.us.test(numStr)) {
                    return parseFloat(numStr.replace(/,/g, ''));
                }

                // Simple decimal with dot (123.45)
                if (patterns.simpleDot.test(numStr)) {
                    return parseFloat(numStr);
                }

                // Simple decimal with comma (123,45)
                if (patterns.simpleComma.test(numStr)) {
                    return parseFloat(numStr.replace(',', '.'));
                }

                // Thousands only with dots (1.234) - assume European style
                if (patterns.thousandsDot.test(numStr)) {
                    return parseFloat(numStr.replace(/\./g, ''));
                }

                // Thousands only with commas (1,234) - assume US style
                if (patterns.thousandsComma.test(numStr)) {
                    return parseFloat(numStr.replace(/,/g, ''));
                }

                // Handle ambiguous cases based on position and context
                if (dotCount === 1 && commaCount === 0) {
                    // Could be decimal (12.50) or thousands (1.200)
                    const parts = numStr.split('.');
                    if (parts[1].length <= 2) {
                        // Likely decimal (12.50)
                        return parseFloat(numStr);
                    } else {
                        // Likely thousands (1.200)
                        return parseFloat(parts[0] + parts[1]);
                    }
                }

                if (commaCount === 1 && dotCount === 0) {
                    // Could be decimal (12,50) or thousands (1,200)
                    const parts = numStr.split(',');
                    if (parts[1].length <= 2) {
                        // Likely decimal (12,50)
                        return parseFloat(numStr.replace(',', '.'));
                    } else {
                        // Likely thousands (1,200)
                        return parseFloat(parts[0] + parts[1]);
                    }
                }

                // Mixed format detection - look at the last separator
                const lastDot = numStr.lastIndexOf('.');
                const lastComma = numStr.lastIndexOf(',');

                if (lastDot > lastComma) {
                    // Last separator is dot, assume US format
                    const beforeDot = numStr.substring(0, lastDot);
                    const afterDot = numStr.substring(lastDot + 1);

                    // If after dot is 1-2 digits, it's likely decimal
                    if (afterDot.length <= 2 && /^\d+$/.test(afterDot)) {
                        const cleanBefore = beforeDot.replace(/,/g, '');
                        return parseFloat(cleanBefore + '.' + afterDot);
                    }
                }

                if (lastComma > lastDot) {
                    // Last separator is comma, assume European format
                    const beforeComma = numStr.substring(0, lastComma);
                    const afterComma = numStr.substring(lastComma + 1);

                    // If after comma is 1-2 digits, it's likely decimal
                    if (afterComma.length <= 2 && /^\d+$/.test(afterComma)) {
                        const cleanBefore = beforeComma.replace(/\./g, '');
                        return parseFloat(cleanBefore + '.' + afterComma);
                    }
                }

                // Fallback: try to clean and parse
                const cleaned = numStr.replace(/[^\d.,]/g, '');
                if (cleaned.includes('.') && cleaned.includes(',')) {
                    // Both separators present, use heuristic
                    if (lastDot > lastComma) {
                        return parseFloat(cleaned.replace(/,/g, ''));
                    } else {
                        return parseFloat(cleaned.replace(/\./g, '').replace(',', '.'));
                    }
                } else if (cleaned.includes('.')) {
                    return parseFloat(cleaned.replace(',', '.'));
                } else if (cleaned.includes(',')) {
                    return parseFloat(cleaned.replace(',', '.'));
                } else {
                    return parseFloat(cleaned);
                }

            } catch (error) {
                console.error('Error parsing number:', numStr, error);
                return NaN;
            }
        }

        function formatNumber(amount) {
            try {
                // Use browser's locale for number formatting
                const locale = navigator.language || 'pt-BR';
                return amount.toLocaleString(locale, {
                    minimumFractionDigits: 2,
                    maximumFractionDigits: 2
                });
            } catch (error) {
                console.error('Error formatting number:', error);
                // Fallback to fixed decimal if locale formatting fails
                return amount.toFixed(2);
            }
        }

        function formatCurrency(amount) {
            try {
                // Format as currency using browser's locale
                const locale = navigator.language || 'pt-BR';
                return amount.toLocaleString(locale, {
                    style: 'currency',
                    currency: getCurrencyCode(locale),
                    minimumFractionDigits: 2,
                    maximumFractionDigits: 2
                });
            } catch (error) {
                console.error('Error formatting currency:', error);
                // Fallback to regular number formatting
                return formatNumber(amount);
            }
        }

        function getCurrencyCode(locale) {
            // Map common locales to currency codes
            const currencyMap = {
                'pt-BR': 'BRL',
                'pt-PT': 'EUR',
                'en-US': 'USD',
                'en-GB': 'GBP',
                'es-ES': 'EUR',
                'fr-FR': 'EUR',
                'de-DE': 'EUR',
                'it-IT': 'EUR'
            };

            return currencyMap[locale] || currencyMap[locale.split('-')[0]] || 'USD';
        }

        // Safely escape HTML characters in user input to prevent HTML injection
        // This function handles characters like <, >, &, and quotes
        function escapeHtml(text) {
            if (text == null || text === undefined) {
                return '';
            }
            const div = document.createElement('div');
            div.textContent = String(text);
            return div.innerHTML;
        }

        function validateExpenses(text) {
            const lines = text.split('\n').map(line => line.trim());
            const warnings = [];
            const people = [];
            const personData = {};

            // First pass: collect all person names
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                if (line === '') continue;

                const expenseMatch = line.match(/^(\d+(?:[.,]\d+)*(?:[.,]\d{1,2})?)/);
                if (!expenseMatch && line.length > 0) {
                    people.push(line);

                    // Parse person info for display name
                    const numberMatch = line.match(/(\d+)/);
                    let displayName = line;
                    if (numberMatch) {
                        displayName = line
                            .replace(/\s*\(\s*\d+\s*\)\s*/g, ' ')
                            .replace(/\s*-\s*\d+\s*/g, ' ')
                            .replace(/\s+\d+\s*$/g, '')
                            .replace(/^\s*\d+\s+/g, '')
                            .replace(/\s+/g, ' ')
                            .trim();
                    }
                    if (!displayName) {
                        displayName = line.replace(/\d+/g, '').trim() || line;
                    }

                    personData[line] = { displayName, originalName: line };
                }
            }

            // Second pass: check for ambiguous references in shared expenses
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                if (line === '') continue;

                const sharedMatch = line.match(/^(\d+(?:[.,]\d+)*(?:[.,]\d{1,2})?)(.+?)\s*-\s*(.+)$/);
                if (sharedMatch) {
                    const peopleStr = sharedMatch[3].trim();
                    const peopleRefs = peopleStr.split(',').map(p => p.trim());

                    for (const personRef of peopleRefs) {
                        // Skip empty references (e.g., from trailing commas like "D,")
                        if (personRef.trim() === '') {
                            continue;
                        }

                        // Find potential matches
                        const exactMatches = people.filter(name => name === personRef);
                        const partialMatches = people.filter(name =>
                            name.toLowerCase().startsWith(personRef.toLowerCase())
                        );
                        const displayMatches = people.filter(name => {
                            const info = personData[name];
                            return info && info.displayName.toLowerCase().startsWith(personRef.toLowerCase());
                        });

                        // Check for ambiguity
                        const allMatches = [...new Set([...exactMatches, ...partialMatches, ...displayMatches])];

                        if (allMatches.length > 1) {
                            const matchingNames = allMatches.map(name => personData[name].displayName).join(', ');
                            warnings.push({
                                line: i + 1,
                                text: line,
                                error: `"${personRef}" é ambíguo - pode se referir a: ${matchingNames}`
                            });
                        } else if (allMatches.length === 0) {
                            warnings.push({
                                line: i + 1,
                                text: line,
                                error: `"${personRef}" não corresponde a nenhuma pessoa listada`
                            });
                        }
                    }
                }
            }

            return warnings;
        }

        function parseExpenses(text) {
            try {
                const lines = text.split('\n').map(line => line.trim());
                const people = {};
                const sharedExpenses = [];
                let currentPerson = null;

                // Helper function to extract name and parts from a person string
                function parsePersonName(personString) {
                    // Look for numbers in the string (e.g., "David 3", "David (3)", "David-3", etc.)
                    const numberMatch = personString.match(/(\d+)/);
                    const parts = numberMatch ? parseInt(numberMatch[1]) : 1;

                    // Remove the number and any surrounding punctuation/spaces for display name
                    let displayName = personString;
                    if (numberMatch) {
                        // Remove the matched number and surrounding characters more carefully
                        displayName = personString
                            .replace(/\s*\(\s*\d+\s*\)\s*/g, ' ')  // Replace (3) with space
                            .replace(/\s*-\s*\d+\s*/g, ' ')        // Replace -3 with space
                            .replace(/\s+\d+\s*$/g, '')           // Remove trailing number
                            .replace(/^\s*\d+\s+/g, '')           // Remove leading number
                            .replace(/\s+/g, ' ')                 // Normalize multiple spaces
                            .trim();
                    }

                    // Fallback to original string if displayName is empty
                    if (!displayName) {
                        displayName = personString.replace(/\d+/g, '').trim() || personString;
                    }

                    return {
                        displayName: displayName,
                        parts: parts,
                        originalName: personString
                    };
                }

                // First pass: collect all person names with their parts
                const allNames = [];
                const personData = {};
                for (const line of lines) {
                    if (line === '') continue;

                    const expenseMatch = line.match(/^(\d+(?:[.,]\d+)*(?:[.,]\d{1,2})?)/);
                    if (!expenseMatch && line.length > 0) {
                        const personInfo = parsePersonName(line);
                        allNames.push(line);
                        personData[line] = personInfo;
                    }
                }

                // Initialize people objects
                allNames.forEach(name => {
                    people[name] = {
                        expenses: [],
                        total: 0,
                        sharedExpenses: [],
                        displayName: personData[name].displayName,
                        parts: personData[name].parts
                    };

                });

                // Second pass: process expenses
                for (const line of lines) {
                    if (line === '') {
                        currentPerson = null;
                        continue;
                    }

                    // Enhanced regex to capture numbers with various formats
                    const expenseMatch = line.match(/^(\d+(?:[.,]\d+)*(?:[.,]\d{1,2})?)/);

                    if (expenseMatch && currentPerson) {
                        // Parse shared expense or default to all people
                        const sharedExpense = parseSharedExpense(line, allNames, personData);
                        const amount = parseNumber(expenseMatch[1]);
                        const description = line.substring(expenseMatch[0].length).trim();

                        if (!isNaN(amount) && amount >= 0 && allNames.length > 0) {
                            let finalSharedExpense;

                            if (sharedExpense) {
                                // Use specific shared expense
                                finalSharedExpense = {
                                    ...sharedExpense,
                                    paidBy: currentPerson
                                };
                            } else {
                                // Default to shared by all people
                                finalSharedExpense = {
                                    amount: amount,
                                    description: description,
                                    sharedWith: allNames,
                                    paidBy: currentPerson
                                };
                            }

                            sharedExpenses.push(finalSharedExpense);

                            // Add the full amount to the person who paid
                            people[currentPerson].expenses.push({
                                amount: amount,
                                description: sharedExpense ? `${finalSharedExpense.description} - ${finalSharedExpense.sharedWith.join(', ')}` : description
                            });
                            people[currentPerson].total += amount;

                            // Track shared expenses for each participant (amounts will be calculated later)
                            finalSharedExpense.sharedWith.forEach(person => {
                                if (people[person]) {
                                    people[person].sharedExpenses.push({
                                        expense: finalSharedExpense,
                                        description: finalSharedExpense.description,
                                        paidBy: currentPerson
                                    });
                                }
                            });
                        }
                    } else if (!expenseMatch && line.length > 0) {
                        // This is a person's name
                        currentPerson = line;
                        if (!people[currentPerson]) {
                            people[currentPerson] = {
                                expenses: [],
                                total: 0,
                                sharedExpenses: []
                            };
                        }
                    }
                }

                return { people, sharedExpenses };
            } catch (error) {
                console.error('Error parsing expenses:', error);
                return { people: {}, sharedExpenses: [] };
            }
        }

        function calculateFairShares(names, sharedExpenses, peopleData) {
            // Calculate total amounts each person owes across all shared expenses
            // Now uses parts/shares for proportional division instead of equal splits
            const totalOwed = {};
            names.forEach(name => {
                totalOwed[name] = 0;
            });

            sharedExpenses.forEach(expense => {
                const { amount, sharedWith } = expense;
                const amountCents = Math.round(amount * 100);

                // Calculate total parts for this expense
                const totalParts = sharedWith.reduce((sum, person) => {
                    const parts = peopleData[person] ? peopleData[person].parts : 1;
                    return sum + parts;
                }, 0);



                // Distribute the expense based on parts
                let distributedCents = 0;
                const distributions = [];

                sharedWith.forEach(person => {
                    const parts = peopleData[person] ? peopleData[person].parts : 1;
                    const personShareCents = Math.round((amountCents * parts) / totalParts);

                    distributions.push({ person, amount: personShareCents });
                    distributedCents += personShareCents;
                });

                // Handle any rounding difference
                const difference = amountCents - distributedCents;
                if (difference !== 0) {
                    // Add the difference to the person with the highest parts (most fair)
                    const maxPartsParticipant = sharedWith.reduce((max, person) => {
                        const parts = peopleData[person] ? peopleData[person].parts : 1;
                        const maxParts = peopleData[max] ? peopleData[max].parts : 1;
                        return parts > maxParts ? person : max;
                    });

                    const adjustmentIndex = distributions.findIndex(d => d.person === maxPartsParticipant);
                    if (adjustmentIndex !== -1) {
                        distributions[adjustmentIndex].amount += difference;
                    }
                }

                // Apply the distributions
                distributions.forEach(({ person, amount }) => {
                    totalOwed[person] += amount;
                });
            });

            // Convert cents to dollars for final fair shares
            const fairShares = {};
            names.forEach(name => {
                fairShares[name] = totalOwed[name] / 100;
            });

            return fairShares;
        }

        function calculateSettlements(people, sharedExpenses) {
            try {
                const names = Object.keys(people);
                if (names.length === 0) return [];

                const fairShares = calculateFairShares(names, sharedExpenses, people);

                // Convert back to dollars and calculate balances
                const balances = {};
                names.forEach(name => {
                    balances[name] = 0;
                });

                // Calculate balances: what each person paid minus what they owe
                names.forEach(name => {
                    const totalPaid = people[name].total;
                    const totalShouldPay = fairShares[name];
                    balances[name] = totalPaid - totalShouldPay;
                });



                // Calculate settlements
                const settlements = [];
                const debtors = names.filter(name => balances[name] < -0.01).map(name => ({
                    name,
                    amount: Math.abs(balances[name])
                })).sort((a, b) => b.amount - a.amount);

                const creditors = names.filter(name => balances[name] > 0.01).map(name => ({
                    name,
                    amount: balances[name]
                })).sort((a, b) => b.amount - a.amount);

                let i = 0, j = 0;
                while (i < debtors.length && j < creditors.length) {
                    const debtor = debtors[i];
                    const creditor = creditors[j];
                    const amount = Math.min(debtor.amount, creditor.amount);

                    if (amount > 0.01) {
                        settlements.push({
                            from: debtor.name,
                            to: creditor.name,
                            amount: amount
                        });

                        debtor.amount -= amount;
                        creditor.amount -= amount;
                    }

                    if (debtor.amount < 0.01) i++;
                    if (creditor.amount < 0.01) j++;
                }

                return settlements;
            } catch (error) {
                console.error('Error calculating settlements:', error);
                return [];
            }
        }



        function generateTextSummary() {
            try {
                const names = Object.keys(currentPeopleData);
                if (names.length === 0) return '';

                const totalExpenses = names.reduce((sum, name) => {
                    return sum + (currentPeopleData[name] ? currentPeopleData[name].total || 0 : 0);
                }, 0);

                // Calculate fair shares using the helper function
                const fairShares = calculateFairShares(names, currentSharedExpenses, currentPeopleData);

                let text = '';

                // Calculate maximum width for amounts across all expenses
                let maxWidth = 0;
                names.forEach(name => {
                    const person = currentPeopleData[name];
                    if (person && person.expenses.length > 0) {
                        person.expenses.forEach(expense => {
                            const width = formatNumber(expense.amount).length;
                            if (width > maxWidth) maxWidth = width;
                        });
                    }
                });

                // Add parsed expenses by person
                text += '*GASTOS*\n';
                names.forEach(name => {
                    const person = currentPeopleData[name];
                    const displayName = person ? person.displayName : name;
                    const parts = person ? person.parts : 1;
                    const partsText = parts > 1 ? ` (${parts})` : '';
                    text += `${displayName}${partsText}\n`;
                    if (person && person.expenses.length > 0) {
                        person.expenses.forEach(expense => {
                            const formattedAmount = formatNumber(expense.amount);
                            const paddedAmount = formattedAmount.padStart(maxWidth, ' ');
                            const description = expense.description ? ` ${expense.description}` : '';
                            text += ` ${paddedAmount}${description}\n`;
                        });
                        text += '\n';
                    }

                });

                // Add summary
                text += '\n*DIVISÃO*\n';
                names.forEach(name => {
                    const personTotal = currentPeopleData[name] ? currentPeopleData[name].total || 0 : 0;
                    const personShare = fairShares[name] || 0;
                    const person = currentPeopleData[name];
                    const displayName = person ? person.displayName : name;
                    const parts = person ? person.parts : 1;
                    const partsText = parts > 1 ? ` (${parts})` : '';
                    text += `${displayName}${partsText} = ${formatNumber(personShare)}\n`;
                });

                text += `Total = ${formatNumber(totalExpenses)}\n`;

                // Add settlements
                text += '\n*ACERTOS*\n';
                if (totalExpenses === 0) {
                    text += 'Nenhum gasto para acertar\n';
                } else if (currentSettlements.length === 0) {
                    text += 'Todos estão quites!\n';
                } else {
                    currentSettlements.forEach(settlement => {
                        const fromPerson = currentPeopleData[settlement.from];
                        const toPerson = currentPeopleData[settlement.to];
                        const fromName = fromPerson ? fromPerson.displayName : settlement.from;
                        const toName = toPerson ? toPerson.displayName : settlement.to;
                        text += `${fromName} deve ${formatNumber(settlement.amount)} para ${toName}\n`;
                    });
                }

                return text;
            } catch (error) {
                console.error('Error generating text summary:', error);
                return 'Erro ao gerar resumo';
            }
        }

        function copyToClipboard() {
            try {
                const textSummary = generateTextSummary();

                if (!textSummary) {
                    alert('Nada para copiar. Adicione alguns gastos primeiro.');
                    return;
                }

                // Try to use the modern clipboard API
                if (navigator.clipboard && window.isSecureContext) {
                    navigator.clipboard.writeText(textSummary).then(() => {
                        showCopySuccess();
                    }).catch(err => {
                        console.error('Failed to copy with clipboard API:', err);
                        fallbackCopy(textSummary);
                    });
                } else {
                    fallbackCopy(textSummary);
                }
            } catch (error) {
                console.error('Error copying to clipboard:', error);
                alert('Erro ao copiar. Tente novamente.');
            }
        }

        function fallbackCopy(text) {
            try {
                // Fallback method using textarea
                const textArea = document.createElement('textarea');
                textArea.value = text;
                textArea.style.position = 'fixed';
                textArea.style.left = '-999999px';
                textArea.style.top = '-999999px';
                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();

                const successful = document.execCommand('copy');
                document.body.removeChild(textArea);

                if (successful) {
                    showCopySuccess();
                } else {
                    alert('Não foi possível copiar automaticamente. Selecione e copie manualmente.');
                }
            } catch (err) {
                console.error('Fallback copy failed:', err);
                alert('Erro ao copiar. Tente selecionar e copiar manualmente.');
            }
        }

        function showCopySuccess() {
            const button = document.getElementById('copyButton');
            const originalText = button.textContent;
            button.textContent = 'COPIADO ✓';
            button.classList.add('copied');

            setTimeout(() => {
                button.textContent = originalText;
                button.classList.remove('copied');
            }, 2000);
        }

        function displayValidationWarnings(warnings) {
            const warningDiv = document.getElementById('validationWarning');
            const contentDiv = document.getElementById('validationContent');

            if (warnings.length === 0) {
                warningDiv.style.display = 'none';
                return;
            }

            let content = '';
            warnings.forEach(warning => {
                content += `
                    <div>
                        ${warning.error}
                    </div>
                `;
            });

            contentDiv.innerHTML = content;
            warningDiv.style.display = 'block';
        }

        function updateResults() {
            try {
                const input = document.getElementById('expenseInput').value;
                const resultsDiv = document.getElementById('results');
                const copyButton = document.getElementById('copyButton');

                // Validate input and show warnings
                const warnings = validateExpenses(input);

                if (!input.trim()) {
                    resultsDiv.innerHTML = '<div class="no-data">Adicione despesas acima para ver a divisão e acertos</div>';
                    copyButton.style.display = 'none';
                    displayValidationWarnings([]);
                    currentPeopleData = {};
                    currentSettlements = [];
                    currentSharedExpenses = [];
                    return;
                }

                // Display validation warnings
                displayValidationWarnings(warnings);

                // If there are critical validation errors, don't proceed with parsing
                if (warnings.length > 0) {
                    resultsDiv.innerHTML = '<div class="no-data">Verifique os erros acima antes de continuar</div>';
                    copyButton.style.display = 'none';
                    currentPeopleData = {};
                    currentSettlements = [];
                    currentSharedExpenses = [];
                    return;
                }

                const { people, sharedExpenses } = parseExpenses(input);
                const names = Object.keys(people);

                if (names.length === 0) {
                    resultsDiv.innerHTML = '<div class="no-data">Nenhum nome válido encontrado</div>';
                    copyButton.style.display = 'none';
                    currentPeopleData = {};
                    currentSettlements = [];
                    currentSharedExpenses = [];
                    return;
                }

                // Store current data for copying
                currentPeopleData = people;
                currentSharedExpenses = sharedExpenses;
                currentSettlements = calculateSettlements(people, sharedExpenses);

                const totalExpenses = names.reduce((sum, name) => {
                    return sum + (people[name] ? people[name].total || 0 : 0);
                }, 0);

                // Calculate fair share amounts using the helper function
                const fairShares = calculateFairShares(names, sharedExpenses, people);

                let html = '';

                // Show individual totals with fair shares
                names.forEach(name => {
                    const personTotal = people[name] ? people[name].total || 0 : 0;
                    const fairShare = fairShares[name] || 0;
                    const displayName = people[name] ? people[name].displayName : name;
                    const parts = people[name] ? people[name].parts : 1;
                    const partsText = parts > 1 ? ` (${parts})` : '';
                    html += `
                        <div class="person-summary">
                            <span class="person-name">${escapeHtml(displayName)}${partsText}</span>
                            <span class="person-total">${formatNumber(fairShare)}</span>
                        </div>
                    `;
                });

                html += `
                    <div class="person-summary total-row">
                        <span class="person-name">Total</span>
                        <span class="person-total">${formatNumber(totalExpenses)}</span>
                    </div>`;

                // Show settlements

                if (totalExpenses === 0) {
                    html += '<div class="no-data">Nenhuma despesa para acertar</div>';
                } else if (currentSettlements.length === 0) {
                    html += '<div class="no-data">Tudo está acertado!</div>';
                } else {
                    currentSettlements.forEach((settlement, index) => {
                        const fromPerson = people[settlement.from];
                        const toPerson = people[settlement.to];
                        const fromName = fromPerson ? fromPerson.displayName : settlement.from;
                        const toName = toPerson ? toPerson.displayName : settlement.to;
                        html += `
                            <div class="settlement-wrapper" data-settlement-index="${index}">
                                <span class="settlement-text">${escapeHtml(fromName)} deve ${formatNumber(settlement.amount)} para ${escapeHtml(toName)}</span>
                                <button class="settle-button" onclick="settlePayment(${index})">✓<span class="settle-text"> ACERTADO</span></button>
                            </div>
                        `;
                    });
                }

                resultsDiv.innerHTML = html;

                // Show copy button when there are results
                copyButton.style.display = 'block';

            } catch (error) {
                console.error('Error updating results:', error);
                document.getElementById('results').innerHTML = '<div class="no-data">Erro ao processar os dados. Verifique o formato.</div>';
                document.getElementById('copyButton').style.display = 'none';
                currentPeopleData = {};
                currentSettlements = [];
                currentSharedExpenses = [];
            }
        }

        function settlePayment(settlementIndex) {
            try {
                const settlement = currentSettlements[settlementIndex];
                if (!settlement) return;

                const textarea = document.getElementById('expenseInput');
                const currentText = textarea.value;

                // Create the payment line in the format: "amount Acerto - recipient"
                const paymentLine = `${formatNumber(settlement.amount)} Acerto - ${settlement.to}`;

                // Find the payer's section and add the payment line
                const lines = currentText.split('\n');
                let payerIndex = -1;

                // Find where the payer's section starts
                for (let i = 0; i < lines.length; i++) {
                    if (lines[i].trim() === settlement.from) {
                        payerIndex = i;
                        break;
                    }
                }

                if (payerIndex !== -1) {
                    // Find the end of the payer's section (next person or end of file)
                    let insertIndex = lines.length;
                    let foundEmptyLine = false;

                    for (let i = payerIndex + 1; i < lines.length; i++) {
                        const line = lines[i].trim();

                        // If we find an empty line, mark it but continue looking
                        if (line === '') {
                            if (!foundEmptyLine) {
                                insertIndex = i;
                                foundEmptyLine = true;
                            }
                            continue;
                        }

                        // Check if this line is a person name (not an expense)
                        const expenseMatch = line.match(/^(\d+(?:[.,]\d+)*(?:[.,]\d{1,2})?)/);
                        if (!expenseMatch && line.length > 0) {
                            // This is a person name, insert before this line (or before the empty line if found)
                            if (!foundEmptyLine) {
                                insertIndex = i;
                            }
                            break;
                        }
                    }

                    // Insert the payment line
                    lines.splice(insertIndex, 0, paymentLine);

                    // Update the textarea
                    textarea.value = lines.join('\n');

                    // Save to localStorage after updating textarea
                    saveToLocalStorage();

                    // Show success state with green background
                    const settlementWrapper = document.querySelector(`[data-settlement-index="${settlementIndex}"]`);
                    if (settlementWrapper) {
                        settlementWrapper.classList.add('settlement-success');

                        // Replace the settlement text with "Acertado"
                        const settlementText = settlementWrapper.querySelector('.settlement-text');
                        if (settlementText) {
                            settlementText.textContent = 'Acertado';
                        }

                        // Hide the button to prevent multiple clicks
                        const button = settlementWrapper.querySelector('.settle-button');
                        if (button) {
                            button.style.display = 'none';
                        }

                        // Remove the settlement after 1 second
                        setTimeout(() => {
                            updateResults();
                        }, 1000);
                    }
                }
            } catch (error) {
                console.error('Error settling payment:', error);
                alert('Erro ao processar acerto. Tente novamente.');
            }
        }

        // Add debounced event listener with error handling
        document.getElementById('expenseInput').addEventListener('input', function() {
            try {
                // Auto-expand textarea first
                autoExpandTextarea(this);

                clearTimeout(debounceTimer);
                debounceTimer = setTimeout(() => {
                    try {
                        updateResults();
                        saveToLocalStorage(); // Save to localStorage after updating results
                    } catch (error) {
                        console.error('Error in updateResults:', error);
                        document.getElementById('results').innerHTML = '<div class="no-data">Erro ao processar os dados. Verifique o formato.</div>';
                        document.getElementById('copyButton').style.display = 'none';
                    }
                }, 300);
            } catch (error) {
                console.error('Error in input handler:', error);
            }
        });

        // Initial calculation with error handling
        try {
            updateResults();
        } catch (error) {
            console.error('Error in initial calculation:', error);
            document.getElementById('results').innerHTML = '<div class="no-data">Erro ao carregar a página. Por favor, recarregue.</div>';
        }
        // localStorage functions
        function resetData() {
            const confirmReset = confirm('Tem certeza que deseja limpar todos os dados? Esta ação não pode ser desfeita.');

            if (confirmReset) {
                try {
                    // Clear the textarea
                    const textarea = document.getElementById('expenseInput');
                    textarea.value = '';

                    // Auto-expand textarea to reset height
                    autoExpandTextarea(textarea);

                    // Clear results
                    document.getElementById('results').innerHTML = '<div class="no-data">Adicione despesas acima para ver a divisão e acertos</div>';

                    // Hide copy button
                    document.getElementById('copyButton').style.display = 'none';

                    // Clear localStorage
                    localStorage.removeItem('expenseInputData');

                    // Reset global variables
                    currentPeopleData = [];
                    currentSettlements = [];
                    currentSharedExpenses = [];
                } catch (error) {
                    console.error('Error resetting data:', error);
                    alert('Erro ao limpar os dados. Tente novamente.');
                }
            }
        }

        function saveToLocalStorage() {
            try {
                const textarea = document.getElementById('expenseInput');
                localStorage.setItem('expenseInputData', textarea.value);
            } catch (error) {
                console.error('Error saving to localStorage:', error);
            }
        }

        function loadFromLocalStorage() {
            try {
                const savedData = localStorage.getItem('expenseInputData');
                if (savedData) {
                    const textarea = document.getElementById('expenseInput');
                    textarea.value = savedData;
                    // Auto-expand after loading content
                    autoExpandTextarea(textarea);
                    // Update results after loading
                    updateResults();
                }
            } catch (error) {
                console.error('Error loading from localStorage:', error);
            }
        }

        // Load saved data when page loads
        // Auto-expanding textarea functionality
        function autoExpandTextarea(textarea) {
            // Reset height to measure the scroll height accurately
            textarea.style.height = 'auto';

            // Detect if we're on mobile based on screen width and touch capability
            const isMobile = window.innerWidth <= 768 || ('ontouchstart' in window && window.innerWidth <= 1024);

            // Calculate available viewport height considering mobile keyboard space
            let availableHeight;
            if (isMobile) {
                // On mobile, use visual viewport if available (accounts for keyboard)
                // Otherwise fall back to a conservative estimate
                if (window.visualViewport) {
                    availableHeight = window.visualViewport.height;
                } else {
                    // Conservative fallback - assume keyboard takes up significant space
                    availableHeight = window.innerHeight * 0.6; // Assume keyboard uses ~40% of screen
                }
            } else {
                availableHeight = window.innerHeight;
            }

            // Calculate new height, ensuring it stays within min/max bounds
            const minHeight = 300; // matches min-height in CSS
            const maxHeightRatio = isMobile ? 0.4 : 0.6; // 40vh on mobile, 60vh on desktop
            const maxHeight = Math.floor(availableHeight * maxHeightRatio);
            const newHeight = Math.max(minHeight, Math.min(textarea.scrollHeight, maxHeight));

            textarea.style.height = newHeight + 'px';
        }

        // Add paste event listener for auto-expand
        document.getElementById('expenseInput').addEventListener('paste', function() {
            // Use setTimeout to allow paste content to be processed first
            setTimeout(() => {
                autoExpandTextarea(this);
            }, 0);
        });

        // Handle window resize to recalculate max height
        window.addEventListener('resize', function() {
            const textarea = document.getElementById('expenseInput');
            if (textarea) {
                autoExpandTextarea(textarea);
            }
        });

        document.addEventListener('DOMContentLoaded', function() {
            loadFromLocalStorage();
            // Set initial height after loading
            const textarea = document.getElementById('expenseInput');
            if (textarea) {
                autoExpandTextarea(textarea);
            }
        });

    </script>
</body>
</html>
