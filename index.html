<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Splitwiser</title>

    <!-- PWA Manifest -->
    <link rel="manifest" href="manifest.json">

    <!-- iOS PWA Meta Tags -->
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-status-bar-style" content="default">
    <meta name="mobile-web-app-title" content="Splitwiser">

    <link rel="icon" type="image/png" href="icons/icon-96x96.png" sizes="96x96" />
    <link rel="icon" type="image/png" href="icons/icon-192x192.png" sizes="192x192" />
    <link rel="icon" type="image/png" href="icons/icon-512x512.png" sizes="512x512" />

    <link rel="icon" type="image/svg+xml" href="favicon.svg" />
    <link rel="shortcut icon" href="favicon.ico" />
    <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png" />

    <!-- Theme color - should match --bg-success in CSS variables -->
    <meta name="theme-color" content="#16a34a">
    <meta name="msapplication-TileColor" content="#16a34a">
    <style>
        :root {
            --font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Fira Code', 'Droid Sans Mono', 'Source Code Pro', 'Consolas', 'Roboto Mono', 'Courier New', monospace;
            --bg-primary: #ede7dc;
            --bg-secondary: #ffffff;
            --bg-tertiary: #f5f2ed;
            --text-primary: #1c1917;
            --text-secondary: #44403c;
            --text-muted: #78716c;
            --text-settlements: #c2410c;
            --text-expenses: #16a34a;
            --text-success: #ffffff;
            --bg-success: #16a34a;
            --shadow-success: rgba(22, 163, 74, 0.3);
            --bg-button-primary: #16a34a;
            --bg-button-primary-hover: #22c55e;
            --text-button-primary: #ffffff;
            --bg-button-secondary: rgba(0, 0, 0, 0.1);
            --bg-button-secondary-hover: rgba(0, 0, 0, 0.2);
            --text-button-secondary: #1c1917;
            --bg-button-settle: #c2410c;
            --bg-button-settle-hover: #ea580c;
            --text-button-settle: #ffffff;
            --bg-settlement-success: #c2410c;
            --text-settlement-success: #ffffff;
            --border-primary: #ede7dc;
            --border-focus: #16a34a;
            --border-expenses: #16a34a;
            --border-settlements: #f97316;
            --bg-error: #fee;
            --text-error: #c53030;
            --border-error: #fc8181;
            --bg-warning:rgba(50,50,50,0.5);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg-primary: #0c0a09;
                --bg-secondary: #1c1917;
                --bg-tertiary: #292524;
                --text-primary: #fafaf9;
                --text-secondary: #d6d3d1;
                --text-muted: #a8a29e;
                --text-settlements: #f97316;
                --text-expenses: #16a34a;
                --text-success: #000000;
                --bg-success: #22c55e;
                --shadow-success: rgba(34, 197, 94, 0.3);
                --bg-button-primary: #22c55e;
                --bg-button-primary-hover: #86efac;
                --text-button-primary: #000000;
                --bg-button-secondary: rgba(255, 255, 255, 0.2);
                --bg-button-secondary-hover: rgba(255, 255, 255, 0.5);
                --text-button-secondary: #fafaf9;
                --bg-button-settle: #f97316;
                --bg-button-settle-hover: #fb923c;
                --text-button-settle: #000000;
                --bg-settlement-success: #f97316;
                --text-settlement-success: #000000;
                --border-primary: #44403c;
                --border-focus: #22c55e;
                --border-expenses: #16a34a;
                --border-settlements: #f97316;
                --bg-error: #2d1b1b;
                --text-error: #fc8181;
                --border-error: #c53030;
                --bg-warning:rgba(50,50,50,0.5);
            }
        }

        body {
            font-family: var(--font-family);
            font-size: 14px;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            padding-bottom: 150px;
            background: var(--bg-primary);
            line-height: 1.6;
            color: var(--text-primary);
            transition: background-color 0.2s, color 0.2s;
        }

        h1 {
            text-align: center;
            color: var(--text-primary);
            margin-bottom: 30px;
            font-weight: 600;
        }
        textarea {
            width: 100%;
            min-height: 300px;
            max-height: 60vh;
            padding: 15px;
            border: 2px solid var(--border-primary);
            border-radius: 8px;
            font-family: var(--font-family);
            font-size: 16px;
            resize: none;
            box-sizing: border-box;
            background: var(--bg-secondary);
            color: var(--text-primary);
            transition: border-color 0.2s, background-color 0.2s, color 0.2s;
            overflow-y: auto;
            white-space: pre;
            overflow-x: auto;
        }

        textarea:focus {
            outline: none;
            border-color: var(--border-focus);
        }

        .results {
            margin-top: 20px;
            border-radius: 8px;
            border: 0;
            overflow: hidden;
            transition: background-color 0.2s, border-color 0.2s;
            text-wrap: balance;
        }

        .summary {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0;
            padding: 10px 16px;
            color: var(--text-primary);
            background: var(--bg-tertiary);
            border-left: 4px solid var(--border-primary);
            transition: background-color 0.2s;
            flex-wrap: wrap;
            gap: 8px;
            width: 100%;
            box-sizing: border-box;
            border-bottom: 1px solid var(--border-primary);
        }

        .summary:last-of-type {
            border-bottom: none;
        }

        .summary .label {
            flex: 2 1 auto;
            white-space: balance;
        }

        .summary .total {
            text-align: right;
            line-height: 1.3;
        }

        .expenses-summary {
            border-left: 4px solid var(--border-expenses);
        }

        .settlements-summary {
            border-left: 4px solid var(--border-settlements);
        }
        .settlements-summary .label {
            margin-right: 8px;
        }

        .expenses-total {
            color: var(--text-expenses);
        }
        .settlements-total {
            color: var(--text-settlements);
        }

        .expenses-total, .settlements-total {
            font-size: 1.1rem;
            font-weight: bold;
        }

        button {
            font-family: var(--font-family);
            font-size: 16px;
            background: var(--bg-button-primary);
            color: var(--text-button-primary);
            border: none;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
        }

        button:hover {
            background: var(--bg-button-primary-hover);
            transform: translateY(-1px);
        }

        button:active {
            transform: translateY(0);
        }

        .actions {
            margin-top: 30px;
            display: flex;
            gap: 15px;
            justify-content: center;
        }

        .copy-button {
            padding: 12px 24px;
            border-radius: 8px;
            flex: 1;
            max-width: 200px;
        }

        .reset-button {
            padding: 12px 24px;
            border-radius: 8px;
            flex: 1;
            max-width: 200px;
            background: var(--bg-button-secondary);
            color: var(--text-button-secondary);
            border: 1px solid var(--border-primary);
        }

        .reset-button:hover {
            background: var(--bg-button-secondary-hover);
        }

        .reset-button:active {
            background: var(--bg-button-secondary-hover);
        }

        .copy-button.copied {
            background: var(--bg-success);
            color: var(--text-success);
        }

        .settle-button {
            padding: 6px 12px;
            border-radius: 4px;
            background: var(--bg-button-settle);
            color: var(--text-button-settle);
        }

        .settle-button:hover {
            background: var(--bg-button-settle-hover);
        }

        .settle-button.settled {
            background: var(--bg-success);
            color: var(--text-success);
            cursor: default;
        }

        .settlements-summary.settlement-success {
            background: var(--bg-settlement-success);
            color: var(--text-settlement-success);
            transform: scale(1.02);
            box-shadow: 0 2px 8px rgba(194, 65, 12, 0.4);
        }

        @media (prefers-color-scheme: dark) {
            .settlements-summary.settlement-success {
                box-shadow: 0 2px 8px rgba(249, 115, 22, 0.4);
            }
        }

        .settlements-summary.settlement-success .label {
            color: var(--text-settlement-success);
            text-align: center;
            font-weight: bold;
        }

        .settlements-summary.settlement-success .settle-button {
            background: var(--bg-button-secondary-hover);
            color: var(--text-settlement-success);
            cursor: default;
        }

        .settlements-summary.all-settled-up {
            color: var(--text-muted);
            font-style: italic;
        }

        .settlements-summary.settlement-log {
            color: var(--text-muted);
            opacity: 0.7;
        }

        .validation-warning {
            background: var(--bg-error);
            color: var(--text-error);
            border: 1px solid var(--border-error);
            border-radius: 8px;
            padding: 12px;
            margin: 10px 0;
            line-height: 1.4;
        }

        .validation-warning .warning-line {
            background: var(--bg-warning);
            padding: 10px 16px;
            border-radius: 4px;
            margin: 8px 0;
            font-family: monospace;
        }

        /* Slide animations */
        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-15px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }



        .slide-in {
            opacity: 0;
            transform: translateY(-15px);
            animation: slideDown 0.3s ease-out forwards;
        }



        @media (max-width: 768px) {
            .settle-text {
                display: none;
            }

            .actions {
                flex-direction: column;
            }

            .copy-button,
            .reset-button {
                max-width: none;
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <textarea id="expenseInput" placeholder=""
onblur="handleBlur()"
onpaste="setTimeout(() => { autoExpandTextarea(this); }, 0)"></textarea>

    <div id="validationWarning" class="validation-warning" style="display: none;">
        <div id="validationContent"></div>
    </div>

    <div class="results" id="expenses-results">
    </div>

    <div class="results" id="settlements-results">
    </div>

    <div class="actions">
        <button class="copy-button" id="copyButton" onclick="copyToClipboard()" style="display: none;"></button>
        <button class="reset-button" id="resetButton" onclick="resetData()" style="display: none;"></button>
    </div>

    <!-- Web Component Templates -->
    <template id="expenses-template">
        <div class="summary expenses-summary">
            <span class="label"></span>
            <span class="total"></span>
        </div>
    </template>

    <template id="settlement-template">
        <div class="summary settlements-summary">
            <span class="label"></span>
            <button class="settle-button">✓<span class="settle-text"></span></button>
        </div>
    </template>

    <template id="settlement-log-template">
        <div class="summary settlements-summary settlement-log">
            <span class="label"></span>
        </div>
    </template>



    <template id="validation-warning-template">
        <div class="warning-line"></div>
    </template>

    <script>
        // Global error handler
        window.onerror = function(message, source, lineno, colno, error) {
            console.error('Global error caught:', message, error);
            const expensesDiv = document.getElementById('expenses-results');
            const settlementsDiv = document.getElementById('settlements-results');
            if (expensesDiv) {
                expensesDiv.innerHTML = '';
            }
            if (settlementsDiv) {
                settlementsDiv.innerHTML = '';
            }
            return true;
        };

        // Promise rejection handler
        window.addEventListener('unhandledrejection', function(event) {
            console.error('Unhandled promise rejection:', event.reason);
            const expensesDiv = document.getElementById('expenses-results');
            const settlementsDiv = document.getElementById('settlements-results');
            if (expensesDiv) {
                expensesDiv.innerHTML = '';
            }
            if (settlementsDiv) {
                settlementsDiv.innerHTML = '';
            }
            event.preventDefault();
        });

        let debounceTimer;
        let currentPeopleData = {};
        let currentSettlements = [];
        let currentTransactions = [];
        let previousResultsHTML = '';
        let previousPeopleCount = 0;
        let previousSettlementCount = 0;
        let previousPeopleNames = [];
        let previousSettlementKeys = [];
        let isSettling = false;

        // Utility function to reset global state variables
        function resetGlobalState() {
            debounceTimer = null;
            currentPeopleData = {};
            currentSettlements = [];
            currentTransactions = [];
            previousResultsHTML = '';
            previousPeopleCount = 0;
            previousSettlementCount = 0;
            previousPeopleNames = [];
            previousSettlementKeys = [];
            isSettling = false;
        }

        // Locale detection and management
        function getLocale() {
            const browserLang = navigator.language || navigator.userLanguage || 'en';
            const lang = browserLang.toLowerCase();

            if (lang.startsWith('pt')) return 'pt-BR';
            if (lang.startsWith('es')) return 'es';
            return 'en';
        }

        const currentLocale = getLocale();

        // Constants for configuration and magic values
        const CONSTANTS = {
            // Timing values (in milliseconds)
            DEBOUNCE_TIMEOUT: 300,
            COPY_SUCCESS_TIMEOUT: 2000,
            SETTLEMENT_SUCCESS_TIMEOUT: 800,

            // Animation delays (in milliseconds)
            PERSON_ANIMATION_DELAY: 50,
            SETTLEMENT_ANIMATION_DELAY: 75,
            TOTAL_ROW_EXTRA_DELAY: 100,

            // Transaction types
            TRANSACTION_TYPES: {
                EXPENSE: 'expense',
                SETTLEMENT: 'settlement'
            },

            // CSS classes
            CSS_CLASSES: {
                SLIDE_IN: 'slide-in',
                COPIED: 'copied',
                SETTLEMENT_SUCCESS: 'settlement-success'
            },

            // Localized strings
            STRINGS: {
                'en': {
                    PROCESSING_ERROR: 'Error processing data. Check the format.',
                    SETTLED_TEXT: 'SETTLED',
                    COPY_SUCCESS: 'COPIED ✓',
                    NOTHING_TO_COPY: 'Nothing to copy. Add some expenses first.',
                    COPY_ERROR: 'Error copying. Try again.',
                    RESET_CONFIRM: 'Are you sure you want to clear all data? This action cannot be undone.',
                    RESET_ERROR: 'Error clearing data. Try again.',
                    EXPENSES: 'Expenses',
                    COSTS: 'Costs',
                    SETTLEMENTS: 'Settlements',
                    TRANSACTIONS: 'Payments',

                    OWES_TEMPLATE: '{fromName} owes {amount} to {toName}',
                    PAID_TEMPLATE: '{fromName} paid {amount} to {toName}',
                    SETTLEMENT_WORD: 'Settlement',
                    PERSON_NOT_FOUND: 'does not match any listed person',
                    AMBIGUOUS_PERSON_TEMPLATE: '"{personRef}" is ambiguous - could refer to: {matchingNames}',
                    PERSON_NOT_FOUND_TEMPLATE: '"{personRef}" {errorMessage}',
                    PAYMENT_LINE_TEMPLATE: '-{amount} {settlementWord} - {toName}',
                    PERSON_WITH_PARTS_TEMPLATE: '{displayName} ({parts})',
                    EXPENSE_WITH_PARTICIPANTS_TEMPLATE: '{description} - {participants}',
                    COPY_MANUAL_SELECT: 'Could not copy automatically. Please select and copy manually.',
                    COPY_MANUAL_FALLBACK: 'Error copying. Try selecting and copying manually.',
                    SETTLEMENT_ERROR: 'Error processing settlement. Try again.',
                    ALL_SETTLED: 'All settled!',
                    NOTHING_TO_SETTLE: 'Nothing to settle!',
                    INVALID_NAME_CHARACTERS: 'Names cannot contain "-" or ">" characters as they have special meanings',
                    COPY_SUMMARY: 'COPY SUMMARY',
                    CLEAR: 'CLEAR',
                    SETTLED_BUTTON: 'SETTLED',
                    NO_DATA_MESSAGE: 'Add expenses above to see division and settlements',
                    ALL_SETTLED_UP: 'Everything is settled!',
                    NO_EXPENSES_TO_SETTLE: 'No expenses to settle',
                    ERROR_GENERATING_SUMMARY: 'Error generating summary',
                    ERROR_LOADING_PAGE: 'Error loading page. Please reload.',
                    PLACEHOLDER: `ADD EXPENSES IN THE FORMAT:

David
18.11 Toll (by default divided among everyone)
1200.00 Hotel (can use dot or comma)

Ana 3 (group of three, will have larger share in division)
45 Restaurant (no need to add cents)
23 Lunch - David, Ana (divided only between David and Ana)

Cristy
50 (description optional)
125.75 Shopping - C,A (can use only initials)
`
                },
                'pt-BR': {
                    PROCESSING_ERROR: 'Erro ao processar os dados. Verifique o formato.',
                    SETTLED_TEXT: 'ACERTADO',
                    COPY_SUCCESS: 'COPIADO ✓',
                    NOTHING_TO_COPY: 'Nada para copiar. Adicione alguns gastos primeiro.',
                    COPY_ERROR: 'Erro ao copiar. Tente novamente.',
                    RESET_CONFIRM: 'Tem certeza que deseja limpar todos os dados? Esta ação não pode ser desfeita.',
                    RESET_ERROR: 'Erro ao limpar os dados. Tente novamente.',
                    EXPENSES: 'Gastos',
                    COSTS: 'Custos',
                    SETTLEMENTS: 'Acertos',
                    TRANSACTIONS: 'Pagamentos',

                    OWES_TEMPLATE: '{fromName} deve {amount} para {toName}',
                    PAID_TEMPLATE: '{fromName} pagou {amount} para {toName}',
                    SETTLEMENT_WORD: 'Acerto',
                    PERSON_NOT_FOUND: 'não corresponde a nenhuma pessoa listada',
                    AMBIGUOUS_PERSON_TEMPLATE: '"{personRef}" é ambíguo - pode se referir a: {matchingNames}',
                    PERSON_NOT_FOUND_TEMPLATE: '"{personRef}" {errorMessage}',
                    PAYMENT_LINE_TEMPLATE: '-{amount} {settlementWord} - {toName}',
                    PERSON_WITH_PARTS_TEMPLATE: '{displayName} ({parts})',
                    EXPENSE_WITH_PARTICIPANTS_TEMPLATE: '{description} - {participants}',
                    COPY_MANUAL_SELECT: 'Não foi possível copiar automaticamente. Selecione e copie manualmente.',
                    COPY_MANUAL_FALLBACK: 'Erro ao copiar. Tente selecionar e copiar manualmente.',
                    SETTLEMENT_ERROR: 'Erro ao processar acerto. Tente novamente.',
                    ALL_SETTLED: 'Tudo acertado!',
                    NOTHING_TO_SETTLE: 'Nada para acertar!',
                    INVALID_NAME_CHARACTERS: 'Nomes não podem conter os caracteres "-" ou ">" pois têm significados especiais',
                    COPY_SUMMARY: 'COPIAR RESUMO',
                    CLEAR: 'LIMPAR',
                    SETTLED_BUTTON: 'ACERTADO',
                    NO_DATA_MESSAGE: 'Adicione despesas acima para ver a divisão e acertos',
                    ALL_SETTLED_UP: 'Tudo está acertado!',
                    NO_EXPENSES_TO_SETTLE: 'Nenhum gasto para acertar',
                    ERROR_GENERATING_SUMMARY: 'Erro ao gerar resumo',
                    ERROR_LOADING_PAGE: 'Erro ao carregar a página. Por favor, recarregue.',
                    PLACEHOLDER: `ADICIONE DESPESAS NO FORMATO:

David
18,11 Pedágio (por padrão dividido entre todos)
1.200,00 Hotel (pode usar ponto ou vírgula)

Ana 3 (grupo de três, terá parte maior na divisão)
45 Restaurante (não precisa colocar centavos)
23 Lanche - David, Ana (dividido somente entre David e Ana)

Cristy
50 (descrição opcional)
125,75 Compras - C,A (pode usar somente iniciais)
`
                },
                'es': {
                    PROCESSING_ERROR: 'Error al procesar los datos. Verifique el formato.',
                    SETTLED_TEXT: 'LIQUIDADO',
                    COPY_SUCCESS: 'COPIADO ✓',
                    NOTHING_TO_COPY: 'Nada que copiar. Agregue algunos gastos primero.',
                    COPY_ERROR: 'Error al copiar. Inténtelo de nuevo.',
                    RESET_CONFIRM: '¿Está seguro de que desea borrar todos los datos? Esta acción no se puede deshacer.',
                    RESET_ERROR: 'Error al borrar los datos. Inténtelo de nuevo.',
                    EXPENSES: 'Gastos',
                    COSTS: 'Costos',
                    SETTLEMENTS: 'Liquidaciones',
                    TRANSACTIONS: 'Pagos',

                    OWES_TEMPLATE: '{fromName} debe {amount} a {toName}',
                    PAID_TEMPLATE: '{fromName} pagó {amount} a {toName}',
                    SETTLEMENT_WORD: 'Liquidación',
                    PERSON_NOT_FOUND: 'no corresponde a ninguna persona listada',
                    AMBIGUOUS_PERSON_TEMPLATE: '"{personRef}" es ambiguo - puede referirse a: {matchingNames}',
                    PERSON_NOT_FOUND_TEMPLATE: '"{personRef}" {errorMessage}',
                    PAYMENT_LINE_TEMPLATE: '-{amount} {settlementWord} - {toName}',
                    PERSON_WITH_PARTS_TEMPLATE: '{displayName} ({parts})',
                    EXPENSE_WITH_PARTICIPANTS_TEMPLATE: '{description} - {participants}',
                    COPY_MANUAL_SELECT: 'No se pudo copiar automáticamente. Seleccione y copie manualmente.',
                    COPY_MANUAL_FALLBACK: 'Error al copiar. Intente seleccionar y copiar manualmente.',
                    SETTLEMENT_ERROR: 'Error al procesar la liquidación. Inténtelo de nuevo.',
                    ALL_SETTLED: '¡Todo liquidado!',
                    NOTHING_TO_SETTLE: '¡Nada que liquidar!',
                    INVALID_NAME_CHARACTERS: 'Los nombres no pueden contener los caracteres "-" o ">" ya que tienen significados especiales',
                    COPY_SUMMARY: 'COPIAR RESUMEN',
                    CLEAR: 'LIMPIAR',
                    SETTLED_BUTTON: 'LIQUIDADO',
                    NO_DATA_MESSAGE: 'Agregue gastos arriba para ver la división y liquidaciones',
                    ALL_SETTLED_UP: '¡Todo está liquidado!',
                    NO_EXPENSES_TO_SETTLE: 'Ningún gasto que liquidar',
                    ERROR_GENERATING_SUMMARY: 'Error al generar resumen',
                    ERROR_LOADING_PAGE: 'Error al cargar la página. Por favor, recargue.',
                    PLACEHOLDER: `AGREGUE GASTOS EN EL FORMATO:

David
18,11 Peaje (por defecto dividido entre todos)
1.200,00 Hotel (puede usar punto o coma)

Ana 3 (grupo de tres, tendrá mayor parte en la división)
45 Restaurante (no necesita poner centavos)
23 Almuerzo - David, Ana (dividido solo entre David y Ana)

Cristy
50 (descripción opcional)
125,75 Compras - C,A (puede usar solo iniciales)
`
                }
            },

            // Helper function to get localized string
            getString: function(key) {
                return this.STRINGS[currentLocale] && this.STRINGS[currentLocale][key]
                    ? this.STRINGS[currentLocale][key]
                    : this.STRINGS['en'][key] || key;
            },

            // Messages (kept for backward compatibility, now uses getString)
            get MESSAGES() {
                const strings = this.STRINGS[currentLocale] || this.STRINGS['en'];
                return {
                    PROCESSING_ERROR: strings.PROCESSING_ERROR,
                    SETTLED_TEXT: strings.SETTLED_TEXT,
                    COPY_SUCCESS: strings.COPY_SUCCESS,
                    NOTHING_TO_COPY: strings.NOTHING_TO_COPY,
                    COPY_ERROR: strings.COPY_ERROR,
                    RESET_CONFIRM: strings.RESET_CONFIRM,
                    RESET_ERROR: strings.RESET_ERROR,
                    EXPENSES: strings.EXPENSES,
                    COSTS: strings.COSTS,
                    SETTLEMENTS: strings.SETTLEMENTS,
                    TRANSACTIONS: strings.TRANSACTIONS,

                    OWES_TEMPLATE: strings.OWES_TEMPLATE,
                    PAID_TEMPLATE: strings.PAID_TEMPLATE,
                    SETTLEMENT_WORD: strings.SETTLEMENT_WORD,
                    PERSON_NOT_FOUND: strings.PERSON_NOT_FOUND,
                    AMBIGUOUS_PERSON_TEMPLATE: strings.AMBIGUOUS_PERSON_TEMPLATE,
                    PERSON_NOT_FOUND_TEMPLATE: strings.PERSON_NOT_FOUND_TEMPLATE,
                    PAYMENT_LINE_TEMPLATE: strings.PAYMENT_LINE_TEMPLATE,
                    PERSON_WITH_PARTS_TEMPLATE: strings.PERSON_WITH_PARTS_TEMPLATE,
                    EXPENSE_WITH_PARTICIPANTS_TEMPLATE: strings.EXPENSE_WITH_PARTICIPANTS_TEMPLATE,
                    COPY_MANUAL_SELECT: strings.COPY_MANUAL_SELECT,
                    COPY_MANUAL_FALLBACK: strings.COPY_MANUAL_FALLBACK,
                    SETTLEMENT_ERROR: strings.SETTLEMENT_ERROR,
                    ALL_SETTLED: strings.ALL_SETTLED,
                    NOTHING_TO_SETTLE: strings.NOTHING_TO_SETTLE,
                    INVALID_NAME_CHARACTERS: strings.INVALID_NAME_CHARACTERS
                };
            },

            // LocalStorage
            STORAGE_KEY: 'expenseInputData',

            // Number formatting
            DEFAULT_LOCALE: currentLocale === 'pt-BR' ? 'pt-BR' : currentLocale === 'es' ? 'es-ES' : 'en-US',
        };

        // Function to initialize UI with localized strings
        function initializeUI() {
            // Set textarea placeholder
            const textarea = document.getElementById('expenseInput');
            textarea.placeholder = CONSTANTS.getString('PLACEHOLDER');

            // Set button texts
            const copyButton = document.getElementById('copyButton');
            copyButton.textContent = CONSTANTS.getString('COPY_SUMMARY');

            const resetButton = document.getElementById('resetButton');
            resetButton.textContent = CONSTANTS.getString('CLEAR');

            // Set settlement button template text
            const settlementTemplate = document.getElementById('settlement-template');
            const settleText = settlementTemplate.content.querySelector('.settle-text');
            settleText.textContent = ' ' + CONSTANTS.getString('SETTLED_BUTTON');
        }

        // Centralized error handling utility
        const ErrorHandler = {
            // Handle UI errors with user-friendly messages
            handleUIError(error, userMessage, showAlert = true) {
                console.error('UI Error:', error);
                if (showAlert) {
                    alert(userMessage);
                }
                // Reset UI state on critical errors
                setButtonVisibility(false);
                resetGlobalState();
            },

            // Handle processing errors with fallback UI
            handleProcessingError(error, fallbackHTML = null) {
                console.error('Processing Error:', error);
                const expensesDiv = document.getElementById('expenses-results');
                const settlementsDiv = document.getElementById('settlements-results');
                expensesDiv.innerHTML = '';
                settlementsDiv.innerHTML = '';
                setButtonVisibility(false);
                resetGlobalState();
            },

            // Handle validation errors
            handleValidationError(error, warnings = []) {
                console.error('Validation Error:', error);
                displayValidationWarnings(warnings);
                setButtonVisibility(false);
            },

            // Log warnings without stopping execution
            logWarning(message, data = null) {
                console.warn('Warning:', message, data);
            }
        };

        // Utility function to manage button visibility
        function setButtonVisibility(show) {
            const copyButton = document.getElementById('copyButton');
            const resetButton = document.getElementById('resetButton');
            const display = show ? 'block' : 'none';

            copyButton.style.display = display;
            resetButton.style.display = display;
        }

        // Utility function to generate person summary HTML
        function generatePersonSummaryHTML(name, fairShare, displayName, parts, shouldAnimate, animationDelay) {
            const template = document.getElementById('expenses-template');
            const clone = template.content.cloneNode(true);

            const animationClass = shouldAnimate ? 'slide-in' : '';

            const wrapper = clone.querySelector('.summary');
            wrapper.className = `summary expenses-summary ${animationClass}`;

            if (shouldAnimate) {
                wrapper.style.animationDelay = `${animationDelay}ms`;
            }

            clone.querySelector('.label').textContent = escapeHtml(formatPersonWithParts(displayName, parts));
            clone.querySelector('.total').textContent = formatNumber(fairShare);

            // Create a temporary div to get the outerHTML
            const tempDiv = document.createElement('div');
            tempDiv.appendChild(clone);
            return tempDiv.innerHTML;
        }

        // Utility function to generate settlement HTML
        function generateSettlementHTML(settlement, index, shouldAnimate, animationDelay, people) {
            const fromPerson = people[settlement.from];
            const toPerson = people[settlement.to];
            const fromName = fromPerson ? fromPerson.displayName : settlement.from;
            const toName = toPerson ? toPerson.displayName : settlement.to;

            const template = document.getElementById('settlement-template');
            const clone = template.content.cloneNode(true);

            const animationClass = shouldAnimate ? 'slide-in' : '';

            const wrapper = clone.querySelector('.settlements-summary');
            wrapper.className = `summary settlements-summary ${animationClass}`;
            wrapper.dataset.settlementIndex = index;

            if (shouldAnimate) {
                wrapper.style.animationDelay = `${animationDelay}ms`;
            }

            clone.querySelector('.label').textContent = formatTemplate(
                CONSTANTS.MESSAGES.OWES_TEMPLATE,
                {
                    fromName: escapeHtml(fromName),
                    amount: formatNumber(settlement.amount),
                    toName: escapeHtml(toName)
                }
            );

            // Add inline onclick handler to the settle button
            const settleButton = clone.querySelector('.settle-button');
            settleButton.setAttribute('onclick', `settlePayment(${index})`);
            settleButton.setAttribute('onmousedown', 'event.preventDefault()');

            // Create a temporary div to get the outerHTML
            const tempDiv = document.createElement('div');
            tempDiv.appendChild(clone);
            return tempDiv.innerHTML;
        }

        // Utility function to generate settlement log HTML
        function generateSettlementLogHTML(settlement, shouldAnimate, animationDelay, people) {
            const template = document.getElementById('settlement-log-template');
            const clone = template.content.cloneNode(true);

            const animationClass = shouldAnimate ? 'slide-in' : '';

            const wrapper = clone.querySelector('.settlements-summary');
            wrapper.className = `summary settlements-summary settlement-log ${animationClass}`;

            if (shouldAnimate) {
                wrapper.style.animationDelay = `${animationDelay}ms`;
            }

            // Get display names for the settlement
            const fromPerson = people[settlement.paidBy];
            const toPerson = people[settlement.settleTo];
            const fromName = fromPerson ? fromPerson.displayName : settlement.paidBy;
            const toName = toPerson ? toPerson.displayName : settlement.settleTo;

            clone.querySelector('.label').textContent = formatTemplate(
                CONSTANTS.MESSAGES.PAID_TEMPLATE,
                {
                    fromName: escapeHtml(fromName),
                    amount: formatNumber(settlement.amount),
                    toName: escapeHtml(toName)
                }
            );

            // Create a temporary div to get the outerHTML
            const tempDiv = document.createElement('div');
            tempDiv.appendChild(clone);
            return tempDiv.innerHTML;
        }

        // Utility function to generate no-data message HTML using template


        // Utility function to generate validation warning HTML using template
        function generateValidationWarningHTML(errorMessage) {
            const template = document.getElementById('validation-warning-template');
            const clone = template.content.cloneNode(true);

            clone.querySelector('.warning-line').textContent = errorMessage;

            // Create a temporary div to get the outerHTML
            const tempDiv = document.createElement('div');
            tempDiv.appendChild(clone);
            return tempDiv.innerHTML;
        }

        // Utility function to validate a person reference and return validation result
        function validatePersonReference(personRef, people, personData) {
            // Skip empty references
            if (!personRef || personRef.trim() === '') {
                return { isValid: true, matches: [] };
            }

            const trimmedRef = personRef.trim();

            // Find potential matches
            const exactMatches = people.filter(name => name === trimmedRef);
            const partialMatches = people.filter(name =>
                name.toLowerCase().startsWith(trimmedRef.toLowerCase())
            );
            const displayMatches = people.filter(name => {
                const info = personData[name];
                return info && info.displayName.toLowerCase().startsWith(trimmedRef.toLowerCase());
            });

            // Get unique matches
            const allMatches = [...new Set([...exactMatches, ...partialMatches, ...displayMatches])];

            return {
                isValid: allMatches.length === 1,
                matches: allMatches,
                isAmbiguous: allMatches.length > 1,
                notFound: allMatches.length === 0,
                personRef: trimmedRef
            };
        }

        function findPersonByNameOrInitial(nameOrInitial, allNames, personData) {
            const validation = validatePersonReference(nameOrInitial, allNames, personData);
            return validation.isValid ? validation.matches[0] : null;
        }

        function parseTransaction(expenseLine, allNames, personData) {
            // Look for settlement pattern: amount > person (settlement format)
            const settlementMatch = expenseLine.match(/^(\d+(?:[.,]\d+)*(?:[.,]\d{1,2})?)\s*>\s*(.+)$/);

            if (settlementMatch) {
                const amount = parseNumber(settlementMatch[1]);
                const personStr = settlementMatch[2].trim();
                const resolvedPerson = findPersonByNameOrInitial(personStr, allNames, personData);

                if (resolvedPerson && !isNaN(amount) && amount > 0) {
                    return {
                        type: CONSTANTS.TRANSACTION_TYPES.SETTLEMENT,
                        amount: amount,
                        description: '',
                        settleTo: resolvedPerson
                    };
                }
            }

            // Look for expense pattern: amount description - person1, person2, person3
            const expenseMatch = expenseLine.match(/^(\d+(?:[.,]\d+)*(?:[.,]\d{1,2})?)(.+?)\s*-\s*(.+)$/);

            if (expenseMatch) {
                const amount = parseNumber(expenseMatch[1]);
                const description = expenseMatch[2].trim();
                const peopleStr = expenseMatch[3].trim();

                // Expense: positive amount
                const peopleNames = peopleStr.split(',').map(p => p.trim());
                const resolvedPeople = [];

                for (const personRef of peopleNames) {
                    const resolvedPerson = findPersonByNameOrInitial(personRef, allNames, personData);
                    if (resolvedPerson) {
                        resolvedPeople.push(resolvedPerson);
                    }
                }

                if (!isNaN(amount) && amount > 0 && resolvedPeople.length > 0) {
                    return {
                        type: CONSTANTS.TRANSACTION_TYPES.EXPENSE,
                        amount: amount,
                        description: description,
                        sharedWith: resolvedPeople
                    };
                }
            }

            return null;
        }

        function parseNumber(numStr) {
            try {
                numStr = numStr.trim();

                // Handle simple integers
                if (/^\d+$/.test(numStr)) {
                    return parseFloat(numStr);
                }

                // Remove any non-digit, non-comma, non-dot characters
                const cleaned = numStr.replace(/[^\d.,]/g, '');
                if (!cleaned) return NaN;

                const lastDot = cleaned.lastIndexOf('.');
                const lastComma = cleaned.lastIndexOf(',');

                // No separators
                if (lastDot === -1 && lastComma === -1) {
                    return parseFloat(cleaned);
                }

                // Only dots or only commas
                if (lastComma === -1) {
                    // Only dots: could be US format (1,234.56) or thousands (1.234)
                    const parts = cleaned.split('.');
                    const lastPart = parts[parts.length - 1];
                    if (lastPart.length <= 2 && parts.length >= 2) {
                        // Likely decimal: 1.234.56 -> 1234.56
                        return parseFloat(parts.slice(0, -1).join('') + '.' + lastPart);
                    } else {
                        // Likely thousands: 1.234 -> 1234
                        return parseFloat(cleaned.replace(/\./g, ''));
                    }
                }

                if (lastDot === -1) {
                    // Only commas: could be European format (1.234,56) or thousands (1,234)
                    const parts = cleaned.split(',');
                    const lastPart = parts[parts.length - 1];
                    if (lastPart.length <= 2 && parts.length >= 2) {
                        // Likely decimal: 123,45 or 1.234,56
                        return parseFloat(cleaned.replace(/\./g, '').replace(',', '.'));
                    } else {
                        // Likely thousands: 1,234 -> 1234
                        return parseFloat(cleaned.replace(/,/g, ''));
                    }
                }

                // Both separators present
                if (lastDot > lastComma) {
                    // Dot comes last: assume US format (1,234.56)
                    const afterDot = cleaned.substring(lastDot + 1);
                    if (afterDot.length <= 2) {
                        return parseFloat(cleaned.replace(/,/g, ''));
                    }
                } else {
                    // Comma comes last: assume European format (1.234,56)
                    const afterComma = cleaned.substring(lastComma + 1);
                    if (afterComma.length <= 2) {
                        return parseFloat(cleaned.replace(/\./g, '').replace(',', '.'));
                    }
                }

                // Fallback: remove all separators except the last one
                const allSeparators = [...cleaned.matchAll(/[.,]/g)];
                if (allSeparators.length > 0) {
                    const lastSeparator = allSeparators[allSeparators.length - 1];
                    const beforeLast = cleaned.substring(0, lastSeparator.index);
                    const afterLast = cleaned.substring(lastSeparator.index + 1);

                    if (afterLast.length <= 2) {
                        // Treat as decimal
                        const cleanBefore = beforeLast.replace(/[.,]/g, '');
                        return parseFloat(cleanBefore + '.' + afterLast);
                    }
                }

                return parseFloat(cleaned.replace(/[.,]/g, ''));
            } catch (error) {
                console.error('Error parsing number:', numStr, error);
                return NaN;
            }
        }

        function formatNumber(amount) {
            try {
                // Prevent negative zero display
                if (amount === 0 || Math.abs(amount) < 0.005) {
                    amount = 0;
                }

                // Use browser's locale for number formatting
                const locale = navigator.language || CONSTANTS.DEFAULT_LOCALE;
                return amount.toLocaleString(locale, {
                    minimumFractionDigits: 2,
                    maximumFractionDigits: 2
                });
            } catch (error) {
                console.error('Error formatting number:', error);
                // Fallback to fixed decimal if locale formatting fails
                // Also handle negative zero in fallback
                if (amount === 0 || Math.abs(amount) < 0.005) {
                    amount = 0;
                }
                return amount.toFixed(2);
            }
        }

        // Safely escape HTML characters in user input to prevent HTML injection
        // This function handles characters like <, >, &, and quotes
        function escapeHtml(text) {
            if (text == null || text === undefined) {
                return '';
            }
            const div = document.createElement('div');
            div.textContent = String(text);
            return div.innerHTML;
        }

        // Format template strings with placeholder replacements
        // Supports placeholders like {name}, {amount}, etc.
        function formatTemplate(template, replacements) {
            if (!template || typeof template !== 'string') {
                return '';
            }

            let result = template;
            for (const [key, value] of Object.entries(replacements || {})) {
                const placeholder = `{${key}}`;
                result = result.replace(new RegExp(placeholder.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g'), String(value || ''));
            }
            return result;
        }

        // Helper function to format person name with parts
        function formatPersonWithParts(displayName, parts) {
            if (parts > 1) {
                return formatTemplate(CONSTANTS.MESSAGES.PERSON_WITH_PARTS_TEMPLATE, {
                    displayName: displayName,
                    parts: parts
                });
            }
            return displayName;
        }

        function validateExpenses(text) {
            const lines = text.split('\n').map(line => line.trim());
            const warnings = [];
            const people = [];
            const personData = {};

            // First pass: collect all person names
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                if (line === '') continue;

                const expenseMatch = line.match(/^(\d+(?:[.,]\d+)*(?:[.,]\d{1,2})?)/);
                const startsWithLetter = /^\s*[a-zA-ZÀ-ÿ]/i.test(line);

                if (!expenseMatch && startsWithLetter && line.length > 0) {
                    // Check for forbidden characters in names
                    if (line.includes('-') || line.includes('>')) {
                        warnings.push({
                            line: i + 1,
                            text: line,
                            error: CONSTANTS.MESSAGES.INVALID_NAME_CHARACTERS
                        });
                        continue; // Skip this line, don't add as a person
                    }

                    people.push(line);

                    // Parse person info for display name - remove ALL numbers
                    let displayName = line.replace(/\d+/g, '').trim();

                    // Clean up any leftover punctuation and spaces
                    displayName = displayName
                        .replace(/\s*\(\s*\)\s*/g, ' ')    // Remove empty parentheses
                        .replace(/\s*-\s*$/g, '')          // Remove trailing hyphens
                        .replace(/^\s*-\s*/g, '')          // Remove leading hyphens
                        .replace(/\s+/g, ' ')              // Normalize multiple spaces
                        .trim();

                    if (!displayName) {
                        displayName = line;
                    }

                    personData[line] = { displayName, originalName: line };
                }
            }

            // Second pass: check for ambiguous references in expenses and validate settlements
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                if (line === '') continue;

                // Check settlement lines (amount > person)
                const settlementMatch = line.match(/^(\d+(?:[.,]\d+)*(?:[.,]\d{1,2})?)\s*>\s*(.+)$/);
                if (settlementMatch) {
                    const personRef = settlementMatch[2].trim();
                    const validation = validatePersonReference(personRef, people, personData);

                    if (validation.isAmbiguous) {
                        const matchingNames = validation.matches.map(name => personData[name].displayName).join(', ');
                        warnings.push({
                            line: i + 1,
                            text: line,
                            error: formatTemplate(CONSTANTS.MESSAGES.AMBIGUOUS_PERSON_TEMPLATE, {
                                personRef: validation.personRef,
                                matchingNames: matchingNames
                            })
                        });
                    } else if (validation.notFound) {
                        warnings.push({
                            line: i + 1,
                            text: line,
                            error: formatTemplate(CONSTANTS.MESSAGES.PERSON_NOT_FOUND_TEMPLATE, {
                                personRef: validation.personRef,
                                errorMessage: CONSTANTS.MESSAGES.PERSON_NOT_FOUND
                            })
                        });
                    }
                }

                // Check expense lines (amount description - person1, person2, ...)
                const sharedMatch = line.match(/^(\d+(?:[.,]\d+)*(?:[.,]\d{1,2})?)(.+?)\s*-\s*(.+)$/);
                if (sharedMatch) {
                    const peopleStr = sharedMatch[3].trim();
                    const peopleRefs = peopleStr.split(',').map(p => p.trim());

                    for (const personRef of peopleRefs) {
                        const validation = validatePersonReference(personRef, people, personData);

                        // Skip empty references
                        if (!validation.personRef) {
                            continue;
                        }

                        if (validation.isAmbiguous) {
                            const matchingNames = validation.matches.map(name => personData[name].displayName).join(', ');
                            warnings.push({
                                line: i + 1,
                                text: line,
                                error: formatTemplate(CONSTANTS.MESSAGES.AMBIGUOUS_PERSON_TEMPLATE, {
                                    personRef: validation.personRef,
                                    matchingNames: matchingNames
                                })
                            });
                        } else if (validation.notFound) {
                            warnings.push({
                                line: i + 1,
                                text: line,
                                error: formatTemplate(CONSTANTS.MESSAGES.PERSON_NOT_FOUND_TEMPLATE, {
                                    personRef: validation.personRef,
                                    errorMessage: CONSTANTS.MESSAGES.PERSON_NOT_FOUND
                                })
                            });
                        }
                    }
                }
            }

            return warnings;
        }

        function parseExpenses(text) {
            try {
                const lines = text.split('\n').map(line => line.trim());
                const people = {};
                const transactions = [];
                let currentPerson = null;

                // Helper function to extract name and parts from a person string
                function parsePersonName(personString) {
                    // Look for the first number in the string for parts count
                    const numberMatch = personString.match(/(\d+)/);
                    const parts = numberMatch ? parseInt(numberMatch[1]) : 1;

                    // Remove ALL numbers from the display name, regardless of format
                    let displayName = personString.replace(/\d+/g, '').trim();

                    // Clean up any leftover punctuation and spaces
                    displayName = displayName
                        .replace(/\s*\(\s*\)\s*/g, ' ')    // Remove empty parentheses
                        .replace(/\s*-\s*$/g, '')          // Remove trailing hyphens
                        .replace(/^\s*-\s*/g, '')          // Remove leading hyphens
                        .replace(/\s+/g, ' ')              // Normalize multiple spaces
                        .trim();

                    // Fallback to original string if displayName is empty after number removal
                    if (!displayName) {
                        displayName = personString;
                    }

                    return {
                        displayName: displayName,
                        parts: parts,
                        originalName: personString
                    };
                }

                // First pass: collect all person names with their parts
                const allNames = [];
                const personData = {};
                for (const line of lines) {
                    if (line === '') continue;

                    const expenseMatch = line.match(/^(\d+(?:[.,]\d+)*(?:[.,]\d{1,2})?)/);
                    const startsWithLetter = /^\s*[a-zA-ZÀ-ÿ]/i.test(line);

                    if (!expenseMatch && startsWithLetter && line.length > 0) {
                        // Skip names with forbidden characters
                        if (line.includes('-') || line.includes('>')) {
                            continue;
                        }
                        const personInfo = parsePersonName(line);
                        allNames.push(line);
                        personData[line] = personInfo;
                    }
                }

                // Initialize people objects
                allNames.forEach(name => {
                    people[name] = {
                        expenses: [],
                        total: 0,
                        displayName: personData[name].displayName,
                        parts: personData[name].parts
                    };
                });

                // Second pass: process transactions
                for (const line of lines) {
                    if (line === '') {
                        currentPerson = null;
                        continue;
                    }

                    // Enhanced regex to capture numbers with various formats (positive only)
                    const expenseMatch = line.match(/^(\d+(?:[.,]\d+)*(?:[.,]\d{1,2})?)/);

                    if (expenseMatch && currentPerson) {
                        // Parse transaction (expense or settlement)
                        const parsedTransaction = parseTransaction(line, allNames, personData);
                        const amount = parseNumber(expenseMatch[1]);
                        const description = line.substring(expenseMatch[0].length).trim();

                        if (!isNaN(amount) && amount > 0 && allNames.length > 0) {
                            let finalTransaction;

                            if (parsedTransaction) {
                                // Use parsed transaction details
                                finalTransaction = {
                                    ...parsedTransaction,
                                    paidBy: currentPerson
                                };
                            } else {
                                // Default amounts to be split among all people
                                finalTransaction = {
                                    type: CONSTANTS.TRANSACTION_TYPES.EXPENSE,
                                    amount: amount,
                                    description: description,
                                    sharedWith: allNames,
                                    paidBy: currentPerson
                                };
                            }

                            transactions.push(finalTransaction);

                            // Add to person's expenses list
                            people[currentPerson].expenses.push({
                                amount: amount,
                                description: finalTransaction.type === CONSTANTS.TRANSACTION_TYPES.EXPENSE && finalTransaction.sharedWith
                                    ? formatTemplate(CONSTANTS.MESSAGES.EXPENSE_WITH_PARTICIPANTS_TEMPLATE, {
                                        description: finalTransaction.description,
                                        participants: finalTransaction.sharedWith.join(', ')
                                    })
                                    : finalTransaction.description,
                                type: finalTransaction.type
                            });
                            people[currentPerson].total += amount;
                        }
                    } else {
                        // Check if this line could be a person's name (starts with letter)
                        const startsWithLetter = /^\s*[a-zA-ZÀ-ÿ]/i.test(line);
                        if (startsWithLetter && line.length > 0) {
                            // Skip names with forbidden characters
                            if (line.includes('-') || line.includes('>')) {
                                currentPerson = null;
                                continue;
                            }
                            // This is a person's name
                            currentPerson = line;
                            if (!people[currentPerson]) {
                                people[currentPerson] = {
                                    expenses: [],
                                    total: 0
                                };
                            }
                        }
                        // If line doesn't match expense format and doesn't start with letter, ignore it
                    }
                }

                return { people, transactions };
            } catch (error) {
                console.error('Error parsing expenses:', error);
                return { people: {}, transactions: [] };
            }
        }

        function calculateFairShares(names, transactions, peopleData) {
            // Calculate total amounts each person owes across all expenses
            // Now uses parts/shares for proportional division instead of equal splits
            const totalOwed = {};
            names.forEach(name => {
                totalOwed[name] = 0;
            });

            // Filter for expenses only and process them
            const expenseTransactions = transactions.filter(t =>
                t.type === CONSTANTS.TRANSACTION_TYPES.EXPENSE
            );

            expenseTransactions.forEach(transaction => {
                const { amount, sharedWith } = transaction;
                const amountCents = Math.round(amount * 100);

                // Calculate total parts for this expense
                const totalParts = sharedWith.reduce((sum, person) => {
                    const parts = peopleData[person] ? peopleData[person].parts : 1;
                    return sum + parts;
                }, 0);

                // Distribute the expense based on parts
                let distributedCents = 0;
                const distributions = [];

                sharedWith.forEach(person => {
                    const parts = peopleData[person] ? peopleData[person].parts : 1;
                    const personShareCents = Math.round((amountCents * parts) / totalParts);

                    distributions.push({ person, amount: personShareCents });
                    distributedCents += personShareCents;
                });

                // Handle any rounding difference
                const difference = amountCents - distributedCents;
                if (difference !== 0) {
                    // Add the difference to the person with the highest parts (most fair)
                    const maxPartsParticipant = sharedWith.reduce((max, person) => {
                        const parts = peopleData[person] ? peopleData[person].parts : 1;
                        const maxParts = peopleData[max] ? peopleData[max].parts : 1;
                        return parts > maxParts ? person : max;
                    });

                    const adjustmentIndex = distributions.findIndex(d => d.person === maxPartsParticipant);
                    if (adjustmentIndex !== -1) {
                        distributions[adjustmentIndex].amount += difference;
                    }
                }

                // Apply the distributions
                distributions.forEach(({ person, amount }) => {
                    totalOwed[person] += amount;
                });
            });

            // Convert cents to dollars for final fair shares
            const fairShares = {};
            names.forEach(name => {
                fairShares[name] = totalOwed[name] / 100;
            });

            return fairShares;
        }

        function calculateSettlements(people, transactions) {
            try {
                const names = Object.keys(people);
                if (names.length === 0) return [];

                const fairShares = calculateFairShares(names, transactions, people);

                // Calculate balances accounting for existing settlements
                const balances = {};
                names.forEach(name => {
                    balances[name] = 0;
                });

                // Start with what each person paid for expenses minus fair share
                names.forEach(name => {
                    // Only count expenses toward what they paid
                    const expensesPaid = people[name].expenses
                        .filter(expense => expense.type === CONSTANTS.TRANSACTION_TYPES.EXPENSE)
                        .reduce((sum, expense) => sum + expense.amount, 0);

                    const totalShouldPay = fairShares[name];
                    balances[name] = expensesPaid - totalShouldPay;
                });

                // Apply existing settlements to adjust balances
                transactions.filter(t => t.type === CONSTANTS.TRANSACTION_TYPES.SETTLEMENT).forEach(settlement => {
                    if (settlement.settleTo) {
                        // Settlement from paidBy to settleTo
                        balances[settlement.paidBy] += settlement.amount; // Payer owes less
                        balances[settlement.settleTo] -= settlement.amount; // Recipient is owed less
                    }
                });

                // Calculate remaining settlements needed
                const settlements = [];
                const debtors = names.filter(name => balances[name] < -0.01).map(name => ({
                    name,
                    amount: Math.abs(balances[name])
                })).sort((a, b) => b.amount - a.amount);

                const creditors = names.filter(name => balances[name] > 0.01).map(name => ({
                    name,
                    amount: balances[name]
                })).sort((a, b) => b.amount - a.amount);

                let i = 0, j = 0;
                while (i < debtors.length && j < creditors.length) {
                    const debtor = debtors[i];
                    const creditor = creditors[j];
                    const amount = Math.min(debtor.amount, creditor.amount);

                    if (amount > 0.01) {
                        settlements.push({
                            from: debtor.name,
                            to: creditor.name,
                            amount: amount
                        });

                        debtor.amount -= amount;
                        creditor.amount -= amount;
                    }

                    if (debtor.amount < 0.01) i++;
                    if (creditor.amount < 0.01) j++;
                }

                return settlements;
            } catch (error) {
                console.error('Error calculating settlements:', error);
                return [];
            }
        }



        function generateTextSummary() {
            try {
                const names = Object.keys(currentPeopleData);
                if (names.length === 0) return '';

                // Calculate total expenses from expense transactions only
                const totalExpenses = currentTransactions
                    .filter(t => t.type === CONSTANTS.TRANSACTION_TYPES.EXPENSE)
                    .reduce((sum, transaction) => sum + transaction.amount, 0);

                // Calculate fair shares using the helper function
                const fairShares = calculateFairShares(names, currentTransactions, currentPeopleData);

                // Get settlement transactions (completed settlements)
                const settlementTransactions = currentTransactions.filter(t => t.type === CONSTANTS.TRANSACTION_TYPES.SETTLEMENT);

                let text = '';

                // BLOCK 1: EXPENSES (expenses only, no settlements)
                const paymentsText = formatPaymentsText();
                if (paymentsText) {
                    text += `*${CONSTANTS.MESSAGES.EXPENSES.toUpperCase()}*\n`;
                    text += paymentsText + '\n';
                }

                // BLOCK 2: COSTS (names and their fair share totals)
                if (totalExpenses === 0) {
                    text += `\n*${CONSTANTS.MESSAGES.COSTS.toUpperCase()}*\n`;
                } else {
                    text += `\n*${CONSTANTS.MESSAGES.COSTS.toUpperCase()}* = ${formatNumber(totalExpenses)}\n`;
                }
                names.forEach(name => {
                    const personShare = fairShares[name] || 0;
                    const person = currentPeopleData[name];
                    const displayName = person ? person.displayName : name;
                    const parts = person ? person.parts : 1;
                    text += `${formatPersonWithParts(displayName, parts)} = ${formatNumber(personShare)}\n`;
                });

                // BLOCK 3: SETTLEMENTS (active settlements + completed settlements)
                // Dynamic header: "*ALL SETTLED*" if no active settlements, "*SETTLEMENTS*" if there are active ones
                const settlementsHeader = (totalExpenses !== 0 && currentSettlements.length === 0)
                    ? `*${CONSTANTS.MESSAGES.ALL_SETTLED.toUpperCase()}*`
                    : `*${CONSTANTS.MESSAGES.SETTLEMENTS.toUpperCase()}*`;

                text += '\n' + settlementsHeader + '\n';

                // First show active settlements that still need to be done
                if (totalExpenses === 0) {
                    text += CONSTANTS.MESSAGES.NOTHING_TO_SETTLE + '\n';
                } else if (currentSettlements.length > 0) {
                    currentSettlements.forEach(settlement => {
                        const fromPerson = currentPeopleData[settlement.from];
                        const toPerson = currentPeopleData[settlement.to];
                        const fromName = fromPerson ? fromPerson.displayName : settlement.from;
                        const toName = toPerson ? toPerson.displayName : settlement.to;
                        text += formatTemplate(CONSTANTS.MESSAGES.OWES_TEMPLATE, {
                            fromName: fromName,
                            amount: formatNumber(settlement.amount),
                            toName: toName
                        }) + '\n';
                    });
                }

                // Then show completed settlements (from settlement transactions)
                if (settlementTransactions.length > 0) {
                    settlementTransactions.forEach(settlement => {
                        const fromPerson = currentPeopleData[settlement.paidBy];
                        const toPerson = currentPeopleData[settlement.settleTo];
                        const fromName = fromPerson ? fromPerson.displayName : settlement.paidBy;
                        const toName = toPerson ? toPerson.displayName : settlement.settleTo;
                        text += formatTemplate(CONSTANTS.MESSAGES.PAID_TEMPLATE, {
                            fromName: fromName,
                            amount: formatNumber(settlement.amount),
                            toName: toName
                        }) + '\n';
                    });
                }

                return text;
            } catch (error) {
                console.error('Error generating text summary:', error);
                return CONSTANTS.MESSAGES.ERROR_GENERATING_SUMMARY;
            }
        }

        function applyFormattedTextToTextarea(saveToStorage = true) {
            try {
                const textarea = document.getElementById('expenseInput');
                const formattedText = formatInputText();

                if (formattedText && formattedText !== textarea.value) {
                    textarea.value = formattedText;
                    autoExpandTextarea(textarea);
                    if (saveToStorage) {
                        saveToLocalStorage();
                    }
                    return true;
                }
                return false;
            } catch (error) {
                ErrorHandler.logWarning('Apply formatted text error', error);
                return false;
            }
        }

        function handleBlur() {
            try {
                // Skip blur handling if we're in the middle of settling a payment
                if (isSettling) {
                    return;
                }

                // Cancel any pending debounced update
                clearTimeout(debounceTimer);

                // Always process current content and update results immediately
                updateResults();
                saveToLocalStorage();

                // Also apply formatting
                applyFormattedTextToTextarea(false); // Don't save again since we just saved
            } catch (error) {
                ErrorHandler.logWarning('Blur handler error', error);
            }
        }

        function formatInputText() {
            try {
                const names = Object.keys(currentPeopleData || {});
                if (names.length === 0) return '';

                let formattedText = '';

                // Calculate maximum width for amounts across all expenses using transactions
                let maxWidth = 0;
                currentTransactions.forEach(transaction => {
                    const width = formatNumber(transaction.amount).length;
                    if (width > maxWidth) maxWidth = width;
                });

                // Ensure minimum width for proper alignment
                if (maxWidth === 0) maxWidth = 8;

                // Format expenses by person using transaction data to reconstruct original format
                names.forEach(name => {
                    const person = currentPeopleData[name];
                    const displayName = person ? person.displayName : name;
                    const parts = person ? person.parts : 1;
                    formattedText += `${formatPersonWithParts(displayName, parts)}\n`;

                    if (person && person.expenses.length > 0) {
                        // Use transactions to reconstruct the original format
                        const processedTransactions = new Set();

                        currentTransactions.forEach(transaction => {
                            if (transaction.paidBy === name && !processedTransactions.has(transaction)) {
                                processedTransactions.add(transaction);

                                let formattedAmount, description = transaction.description || '';

                                if (transaction.type === CONSTANTS.TRANSACTION_TYPES.SETTLEMENT) {
                                    // Settlement: amount > recipient format
                                    formattedAmount = formatNumber(transaction.amount);
                                    if (transaction.settleTo) {
                                        const recipientData = currentPeopleData[transaction.settleTo];
                                        const recipientName = recipientData ? recipientData.displayName : transaction.settleTo;
                                        description = `> ${recipientName}`;
                                    }
                                } else {
                                    // Expense: positive amount
                                    formattedAmount = formatNumber(transaction.amount);

                                    // Check if this expense is split with specific people (not all)
                                    const allNames = Object.keys(currentPeopleData);
                                    const isSharedWithAll = transaction.sharedWith && transaction.sharedWith.length === allNames.length && transaction.sharedWith.every(p => allNames.includes(p));

                                    // Always add participant names unless split among all people
                                    if (!isSharedWithAll && transaction.sharedWith && transaction.sharedWith.length > 0) {
                                        // Add participants to description
                                        const participants = transaction.sharedWith.map(p => {
                                            const participantData = currentPeopleData[p];
                                            return participantData ? participantData.displayName : p;
                                        }).join(', ');
                                        description = description ? `${description} - ${participants}` : `- ${participants}`;
                                    }
                                }

                                const paddedAmount = formattedAmount.padStart(maxWidth, ' ');
                                const fullDescription = description ? ` ${description}` : '';
                                formattedText += `${paddedAmount}${fullDescription}\n`;
                            }
                        });

                        // Also add any individual expenses that aren't part of transactions (like manually entered settlements)
                        person.expenses.forEach(expense => {
                            if (expense.isSettlement) {
                                const formattedAmount = formatNumber(expense.amount);
                                const paddedAmount = formattedAmount.padStart(maxWidth, ' ');
                                const fullDescription = expense.description ? ` ${expense.description}` : '';
                                formattedText += `${paddedAmount}${fullDescription}\n`;
                            }
                        });

                        formattedText += '\n';
                    }
                });

                return formattedText.trim();
            } catch (error) {
                console.error('Error formatting input text:', error);
                return '';
            }
        }

        // Helper function to format only expenses (no settlements) for PAYMENTS block
        function formatPaymentsText() {
            try {
                const names = Object.keys(currentPeopleData || {});
                if (names.length === 0) return '';

                let formattedText = '';

                // Calculate maximum width for amounts across all expense transactions only
                let maxWidth = 0;
                currentTransactions.filter(t => t.type === CONSTANTS.TRANSACTION_TYPES.EXPENSE).forEach(transaction => {
                    const width = formatNumber(transaction.amount).length;
                    if (width > maxWidth) maxWidth = width;
                });

                // Ensure minimum width for proper alignment
                if (maxWidth === 0) maxWidth = 8;

                // Format expenses by person using transaction data (EXPENSES ONLY)
                names.forEach(name => {
                    const person = currentPeopleData[name];
                    const displayName = person ? person.displayName : name;
                    const parts = person ? person.parts : 1;

                    // Check if this person has any expense transactions
                    const hasExpenses = currentTransactions.some(t =>
                        t.paidBy === name && t.type === CONSTANTS.TRANSACTION_TYPES.EXPENSE
                    );

                    if (hasExpenses) {
                        formattedText += `${formatPersonWithParts(displayName, parts)}\n`;

                        // Use transactions to reconstruct the original format (EXPENSES ONLY)
                        const processedTransactions = new Set();

                        currentTransactions.forEach(transaction => {
                            if (transaction.paidBy === name &&
                                transaction.type === CONSTANTS.TRANSACTION_TYPES.EXPENSE &&
                                !processedTransactions.has(transaction)) {
                                processedTransactions.add(transaction);

                                let description = transaction.description || '';
                                const formattedAmount = formatNumber(transaction.amount);

                                // Check if this expense is split with specific people (not all)
                                const allNames = Object.keys(currentPeopleData);
                                const isSharedWithAll = transaction.sharedWith && transaction.sharedWith.length === allNames.length && transaction.sharedWith.every(p => allNames.includes(p));

                                // Always add participant names unless split among all people
                                if (!isSharedWithAll && transaction.sharedWith && transaction.sharedWith.length > 0) {
                                    // Add participants to description
                                    const participants = transaction.sharedWith.map(p => {
                                        const participantData = currentPeopleData[p];
                                        return participantData ? participantData.displayName : p;
                                    }).join(', ');
                                    description = description ? `${description} - ${participants}` : `- ${participants}`;
                                }

                                const paddedAmount = formattedAmount.padStart(maxWidth, ' ');
                                const fullDescription = description ? ` ${description}` : '';
                                formattedText += `${paddedAmount}${fullDescription}\n`;
                            }
                        });

                        formattedText += '\n';
                    }
                });

                return formattedText.trim();
            } catch (error) {
                console.error('Error formatting payments text:', error);
                return '';
            }
        }

        function copyToClipboard() {
            try {
                const textSummary = generateTextSummary();

                if (!textSummary) {
                    alert(CONSTANTS.MESSAGES.NOTHING_TO_COPY);
                    return;
                }

                // Also format and update the input text
                applyFormattedTextToTextarea();

                // Try to use the modern clipboard API
                if (navigator.clipboard && window.isSecureContext) {
                    navigator.clipboard.writeText(textSummary).then(() => {
                        showCopySuccess();
                    }).catch(err => {
                        console.error('Failed to copy with clipboard API:', err);
                        fallbackCopy(textSummary);
                    });
                } else {
                    fallbackCopy(textSummary);
                }
            } catch (error) {
                ErrorHandler.handleUIError(error, CONSTANTS.MESSAGES.COPY_ERROR);
            }
        }

        function fallbackCopy(text) {
            try {
                // Fallback method using textarea
                const textArea = document.createElement('textarea');
                textArea.value = text;
                textArea.style.position = 'fixed';
                textArea.style.left = '-999999px';
                textArea.style.top = '-999999px';
                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();

                const successful = document.execCommand('copy');
                document.body.removeChild(textArea);

                if (successful) {
                    showCopySuccess();
                } else {
                    alert(CONSTANTS.MESSAGES.COPY_MANUAL_SELECT);
                }
            } catch (err) {
                console.error('Fallback copy failed:', err);
                alert(CONSTANTS.MESSAGES.COPY_MANUAL_FALLBACK);
            }
        }

        function showCopySuccess() {
            const button = document.getElementById('copyButton');
            const originalText = button.textContent;
            button.textContent = CONSTANTS.MESSAGES.COPY_SUCCESS;
            button.classList.add(CONSTANTS.CSS_CLASSES.COPIED);

            setTimeout(() => {
                button.textContent = originalText;
                button.classList.remove(CONSTANTS.CSS_CLASSES.COPIED);
            }, CONSTANTS.COPY_SUCCESS_TIMEOUT);
        }

        function displayValidationWarnings(warnings) {
            const warningDiv = document.getElementById('validationWarning');
            const contentDiv = document.getElementById('validationContent');

            if (warnings.length === 0) {
                warningDiv.style.display = 'none';
                return;
            }

            let content = '';
            warnings.forEach(warning => {
                content += generateValidationWarningHTML(warning.error);
            });

            contentDiv.innerHTML = content;
            warningDiv.style.display = 'block';
        }

        function updateResults() {
            try {
                const input = document.getElementById('expenseInput').value;
                const expensesDiv = document.getElementById('expenses-results');
                const settlementsDiv = document.getElementById('settlements-results');
                const copyButton = document.getElementById('copyButton');
                const resetButton = document.getElementById('resetButton');

                // Validate input and show warnings
                const warnings = validateExpenses(input);

                if (!input.trim()) {
                    expensesDiv.innerHTML = '';
                    settlementsDiv.innerHTML = '';
                    setButtonVisibility(false);
                    displayValidationWarnings([]);
                    resetGlobalState();
                    return;
                }

                // Display validation warnings
                displayValidationWarnings(warnings);

                // If there are critical validation errors, don't proceed with parsing
                if (warnings.length > 0) {
                    expensesDiv.innerHTML = '';
                    settlementsDiv.innerHTML = '';
                    setButtonVisibility(false);
                    resetGlobalState();
                    return;
                }

                const { people, transactions } = parseExpenses(input);
                const names = Object.keys(people);

                if (names.length === 0) {
                    expensesDiv.innerHTML = '';
                    settlementsDiv.innerHTML = '';
                    setButtonVisibility(false);
                    resetGlobalState();
                    return;
                }

                // Store current data for copying
                currentPeopleData = people;
                currentTransactions = transactions;
                currentSettlements = calculateSettlements(people, transactions);

                // Calculate total expenses from expense transactions only
                const totalExpenses = transactions
                    .filter(t => t.type === CONSTANTS.TRANSACTION_TYPES.EXPENSE)
                    .reduce((sum, transaction) => sum + transaction.amount, 0);

                // Calculate total settlements from settlement transactions only
                const totalSettlements = transactions
                    .filter(t => t.type === CONSTANTS.TRANSACTION_TYPES.SETTLEMENT)
                    .reduce((sum, transaction) => sum + transaction.amount, 0);

                // Calculate fair share amounts using the helper function
                const fairShares = calculateFairShares(names, transactions, people);

                // Create keys for comparison
                const newPeopleNames = names.slice();
                const newSettlementKeys = currentSettlements.map(s => `${s.from}->${s.to}-${s.amount}`);

                // Find removed items
                const removedPeopleNames = previousPeopleNames.filter(name => !newPeopleNames.includes(name));
                const removedSettlementKeys = previousSettlementKeys.filter(key => !newSettlementKeys.includes(key));

                // If items are being removed, animate them out first
                proceedWithUpdate();

                function proceedWithUpdate() {
                    // Determine if we should animate based on changes
                    const newPeopleCount = names.length + 2; // +2 for gastos and acertos rows
                    const newSettlementCount = currentSettlements.length;
                    const shouldAnimateNewItems = newPeopleCount > previousPeopleCount || newSettlementCount > previousSettlementCount || previousPeopleCount === 0;
                    const isFirstLoad = previousPeopleCount === 0;

                    let expensesHtml = '';
                    let settlementsHtml = '';
                    let animationDelay = 0;

                    // EXPENSES SECTION
                    // Expenses total as header
                    const totalShouldAnimate = isFirstLoad;
                    const totalAnimationClass = totalShouldAnimate ? 'slide-in' : '';
                    const totalAnimationStyle = totalShouldAnimate ? `style="animation-delay: ${animationDelay}ms"` : '';

                        expensesHtml += `
                            <div class="summary expenses-summary expenses-total ${totalAnimationClass}" ${totalAnimationStyle}>
                                <span class="label">${CONSTANTS.MESSAGES.COSTS}</span>
                                <span class="total">${formatNumber(totalExpenses)}</span>
                            </div>`;
                    if (totalShouldAnimate) animationDelay += CONSTANTS.TOTAL_ROW_EXTRA_DELAY;

                    // Show individual fair share expenses (excluding settlements)
                    names.forEach((name, index) => {
                        const fairShare = fairShares[name] || 0;
                        const displayName = people[name] ? people[name].displayName : name;
                        const parts = people[name] ? people[name].parts : 1;

                        const shouldAnimate = shouldAnimateNewItems && index >= previousPeopleCount - 1;
                        expensesHtml += generatePersonSummaryHTML(name, fairShare, displayName, parts, shouldAnimate, animationDelay);
                        if (shouldAnimate) animationDelay += CONSTANTS.PERSON_ANIMATION_DELAY;
                    });

                    // SETTLEMENTS SECTION
                    // Show settlements section if there are any settlements (active or completed)
                    if (totalSettlements !== 0 || currentSettlements.length > 0) {
                        const settlementTotalAnimationStyle = totalShouldAnimate ? `style="animation-delay: ${animationDelay}ms"` : '';

                        // Dynamic title: "All settled!" if no active settlements, "Settlements" if there are active ones
                        const sectionTitle = (totalExpenses !== 0 && currentSettlements.length === 0)
                            ? CONSTANTS.MESSAGES.ALL_SETTLED
                            : CONSTANTS.MESSAGES.SETTLEMENTS;

                        settlementsHtml += `
                            <div class="summary settlements-summary settlements-total ${totalAnimationClass}" ${settlementTotalAnimationStyle}>
                                <span class="label">${sectionTitle}</span>
                            </div>`;

                        if (totalShouldAnimate) animationDelay += CONSTANTS.TOTAL_ROW_EXTRA_DELAY;

                        // Show active settlements
                        if (totalExpenses !== 0 && currentSettlements.length > 0) {
                            currentSettlements.forEach((settlement, index) => {
                                const shouldAnimate = shouldAnimateNewItems && index >= previousSettlementCount;
                                settlementsHtml += generateSettlementHTML(settlement, index, shouldAnimate, animationDelay, people);
                                if (shouldAnimate) animationDelay += CONSTANTS.SETTLEMENT_ANIMATION_DELAY;
                            });
                        }

                        // Show settlement log entries (completed settlements from textarea)
                        const settlementTransactions = transactions.filter(t => t.type === CONSTANTS.TRANSACTION_TYPES.SETTLEMENT);
                        if (settlementTransactions.length > 0) {
                            settlementTransactions.forEach((settlement, index) => {
                                const shouldAnimate = shouldAnimateNewItems;
                                settlementsHtml += generateSettlementLogHTML(settlement, shouldAnimate, animationDelay, people);
                                if (shouldAnimate) animationDelay += CONSTANTS.SETTLEMENT_ANIMATION_DELAY;
                            });
                        }
                    }

                    expensesDiv.innerHTML = expensesHtml;
                    settlementsDiv.innerHTML = settlementsHtml;

                    // Update tracking variables
                    previousResultsHTML = expensesHtml + settlementsHtml;
                    previousPeopleCount = newPeopleCount;
                    previousSettlementCount = newSettlementCount;
                    previousPeopleNames = newPeopleNames.slice();
                    previousSettlementKeys = newSettlementKeys.slice();

                    // Show buttons when there are results
                    setButtonVisibility(true);
                }

            } catch (error) {
                ErrorHandler.handleProcessingError(error);
            }
        }

        function settlePayment(settlementIndex) {
            try {
                // Set flag to prevent blur interference
                isSettling = true;

                const settlement = currentSettlements[settlementIndex];
                if (!settlement) {
                    isSettling = false;
                    return;
                }

                // Get display names for the settlement
                const fromPerson = currentPeopleData[settlement.from];
                const toPerson = currentPeopleData[settlement.to];
                const fromName = fromPerson ? fromPerson.displayName : settlement.from;
                const toName = toPerson ? toPerson.displayName : settlement.to;

                const textarea = document.getElementById('expenseInput');
                const currentText = textarea.value;

                // Create the payment line in the format: "amount > recipient"
                const formattedAmount = formatNumber(Number(settlement.amount));
                const settlementLine = `${formattedAmount} > ${toName}`;

                // Find the payer's section and add the payment line
                const lines = currentText.split('\n');
                let payerIndex = -1;

                // Find where the payer's section starts
                for (let i = 0; i < lines.length; i++) {
                    if (lines[i].trim() === settlement.from) {
                        payerIndex = i;
                        break;
                    }
                }

                if (payerIndex !== -1) {
                    // Find the end of the payer's section (next person or end of file)
                    let insertIndex = lines.length;
                    let foundEmptyLine = false;

                    for (let i = payerIndex + 1; i < lines.length; i++) {
                        const line = lines[i].trim();

                        // If we find an empty line, mark it but continue looking
                        if (line === '') {
                            if (!foundEmptyLine) {
                                insertIndex = i;
                                foundEmptyLine = true;
                            }
                            continue;
                        }

                        // Check if this line is a person name (not an expense)
                        const expenseMatch = line.match(/^(-?\d+(?:[.,]\d+)*(?:[.,]\d{1,2})?)/);
                        if (!expenseMatch && line.length > 0) {
                            // This is a person name, insert before this line (or before the empty line if found)
                            if (!foundEmptyLine) {
                                insertIndex = i;
                            }
                            break;
                        }
                    }

                    // Insert the payment line
                    lines.splice(insertIndex, 0, settlementLine);

                    // Update the textarea
                    textarea.value = lines.join('\n');

                    // Reparse the expenses to update data structures with the new settlement
                    const { people, transactions } = parseExpenses(textarea.value);

                    if (people && transactions) {
                        currentPeopleData = people;
                        currentTransactions = transactions;

                        // Now reformat the input text with updated data
                        applyFormattedTextToTextarea(false); // Don't save to storage here, we'll save below
                    }

                    // Save to localStorage after updating textarea
                    saveToLocalStorage();

                    // Show success state with green background
                    const settlementWrapper = document.querySelector(`[data-settlement-index="${settlementIndex}"]`);
                    if (settlementWrapper) {
                        settlementWrapper.classList.add(CONSTANTS.CSS_CLASSES.SETTLEMENT_SUCCESS);

                        // Replace the settlement text with "Acertado"
                        const settlementText = settlementWrapper.querySelector('.label');
                        if (settlementText) {
                            settlementText.textContent = CONSTANTS.MESSAGES.SETTLED_TEXT;
                        }

                        // Hide the button to prevent multiple clicks
                        const button = settlementWrapper.querySelector('.settle-button');
                        if (button) {
                            button.style.display = 'none';
                        }

                        // Remove the settlement after showing success state
                        setTimeout(() => {
                            updateResults();
                            isSettling = false;
                        }, CONSTANTS.SETTLEMENT_SUCCESS_TIMEOUT);
                    }
                }
            } catch (error) {
                ErrorHandler.handleUIError(error, CONSTANTS.MESSAGES.SETTLEMENT_ERROR);
            } finally {
                // Always reset the settling flag
                setTimeout(() => {
                    isSettling = false;
                }, 100);
            }
        }


        // Add debounced event listener with error handling
        document.getElementById('expenseInput').addEventListener('input', function() {
            try {
                // Auto-expand textarea first
                autoExpandTextarea(this);

                clearTimeout(debounceTimer);
                debounceTimer = setTimeout(() => {
                    try {
                        updateResults();
                        saveToLocalStorage(); // Save to localStorage after updating results
                    } catch (error) {
                        ErrorHandler.handleProcessingError(error);
                    }
                }, CONSTANTS.DEBOUNCE_TIMEOUT);
            } catch (error) {
                ErrorHandler.logWarning('Input handler error', error);
            }
        });


        // Initial calculation with error handling
        try {
            updateResults();
        } catch (error) {
            ErrorHandler.handleProcessingError(error);
        }
        // localStorage functions
        function resetData() {
            const confirmReset = confirm(CONSTANTS.MESSAGES.RESET_CONFIRM);

            if (confirmReset) {
                try {
                    setButtonVisibility(false);

                    // Clear localStorage
                    localStorage.removeItem(CONSTANTS.STORAGE_KEY);

                    const textarea = document.getElementById('expenseInput');
                    textarea.value = '';
                    autoExpandTextarea(textarea);

                    resetGlobalState();
                    updateResults();

                } catch (error) {
                    ErrorHandler.handleUIError(error, CONSTANTS.MESSAGES.RESET_ERROR);
                }
            }
        }

        function saveToLocalStorage() {
            try {
                const textarea = document.getElementById('expenseInput');
                localStorage.setItem(CONSTANTS.STORAGE_KEY, textarea.value);
            } catch (error) {
                console.error('Error saving to localStorage:', error);
            }
        }

        function loadFromLocalStorage() {
            try {
                const savedData = localStorage.getItem(CONSTANTS.STORAGE_KEY);
                if (savedData) {
                    const textarea = document.getElementById('expenseInput');
                    textarea.value = savedData;

                    // Parse and reformat the loaded data
                    const { people, transactions } = parseExpenses(savedData);
                    if (people && transactions) {
                        currentPeopleData = people;
                        currentTransactions = transactions;

                        applyFormattedTextToTextarea(false); // Don't save to storage during load
                    }

                    // Auto-expand after loading content
                    autoExpandTextarea(textarea);
                    // Update results after loading
                    updateResults();
                }
            } catch (error) {
                console.error('Error loading from localStorage:', error);
            }
        }

        // Load saved data when page loads
        // Auto-expanding textarea functionality
        function autoExpandTextarea(textarea) {
            // Reset height to measure the scroll height accurately
            textarea.style.height = 'auto';

            // Detect if we're on mobile based on screen width and touch capability
            const isMobile = window.innerWidth <= 768 || ('ontouchstart' in window && window.innerWidth <= 1024);

            // Calculate available viewport height considering mobile keyboard space
            let availableHeight;
            if (isMobile) {
                // On mobile, use visual viewport if available (accounts for keyboard)
                // Otherwise fall back to a conservative estimate
                if (window.visualViewport) {
                    availableHeight = window.visualViewport.height;
                } else {
                    // Conservative fallback - assume keyboard takes up significant space
                    availableHeight = window.innerHeight * 0.6; // Assume keyboard uses ~40% of screen
                }
            } else {
                availableHeight = window.innerHeight;
            }

            // Calculate new height, ensuring it stays within min/max bounds
            const minHeight = 300; // matches min-height in CSS
            const maxHeightRatio = isMobile ? 0.4 : 0.6; // 40vh on mobile, 60vh on desktop
            const maxHeight = Math.floor(availableHeight * maxHeightRatio);
            const newHeight = Math.max(minHeight, Math.min(textarea.scrollHeight, maxHeight));

            textarea.style.height = newHeight + 'px';
        }


        // Handle window resize to recalculate max height
        window.addEventListener('resize', function() {
            const textarea = document.getElementById('expenseInput');
            if (textarea) {
                autoExpandTextarea(textarea);
            }
        });

        document.addEventListener('DOMContentLoaded', function() {
            initializeUI();
            loadFromLocalStorage();
            // Set initial height after loading
            const textarea = document.getElementById('expenseInput');
            if (textarea) {
                autoExpandTextarea(textarea);
            }
        });

    </script>
</body>
</html>
