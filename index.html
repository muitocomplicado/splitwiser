<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Splitwiser</title>

    <!-- PWA Manifest -->
    <link rel="manifest" href="/manifest.json">

    <!-- iOS PWA Meta Tags -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="Splitwiser">

    <link rel="icon" type="image/png" href="/icons/icon-96x96.png" sizes="96x96" />
    <link rel="icon" type="image/png" href="/icons/icon-192x192.png" sizes="192x192" />
    <link rel="icon" type="image/png" href="/icons/icon-512x512.png" sizes="512x512" />

    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <link rel="shortcut icon" href="/favicon.ico" />
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />

    <!-- Theme color -->
    <meta name="theme-color" content="#16a34a">
    <meta name="msapplication-TileColor" content="#16a34a">
    <style>
        :root {
            --font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Fira Code', 'Droid Sans Mono', 'Source Code Pro', 'Consolas', 'Roboto Mono', 'Courier New', monospace;
            --bg-primary: #fafafa;
            --bg-secondary: #ffffff;
            --bg-tertiary: #f5f5f4;
            --bg-accent: #fef7ed;
            --text-primary: #1c1917;
            --text-secondary: #44403c;
            --text-muted: #78716c;
            --text-accent: #c2410c;
            --text-amount: #ea580c;
            --text-success: #16a34a;
            --border-primary: #e7e5e4;
            --border-accent: #f97316;
            --border-focus: #16a34a;
            --border-summary: #a8a29e;
            --border-total: #16a34a;
            --border-per-person: #059669;
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg-primary: #0c0a09;
                --bg-secondary: #1c1917;
                --bg-tertiary: #292524;
                --bg-accent: #451a03;
                --text-primary: #fafaf9;
                --text-secondary: #d6d3d1;
                --text-muted: #a8a29e;
                --text-accent: #fed7aa;
                --text-amount: #fdba74;
                --text-success: #4ade80;
                --border-primary: #44403c;
                --border-accent: #ea580c;
                --border-focus: #22c55e;
                --border-summary: #78716c;
                --border-total: #22c55e;
                --border-per-person: #10b981;
                --bg-error: #2d1b1b;
                --text-error: #fc8181;
                --border-error: #c53030;
                --bg-code: #2d2d2d;
            }
        }

        body {
            font-family: var(--font-family);
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            padding-bottom: 150px;
            background: var(--bg-primary);
            line-height: 1.6;
            color: var(--text-primary);
            transition: background-color 0.2s, color 0.2s;
        }

        h1 {
            text-align: center;
            color: var(--text-primary);
            margin-bottom: 30px;
            font-weight: 600;
        }

        textarea {
            width: 100%;
            min-height: 300px;
            max-height: 60vh;
            padding: 15px;
            border: 2px solid var(--border-primary);
            border-radius: 8px;
            font-family: var(--font-family);
            font-size: 16px;
            resize: none;
            box-sizing: border-box;
            background: var(--bg-secondary);
            color: var(--text-primary);
            transition: border-color 0.2s, background-color 0.2s, color 0.2s;
            overflow-y: auto;
        }

        textarea:focus {
            outline: none;
            border-color: var(--border-focus);
        }

        .results {
            margin-top: 20px;
            background: var(--bg-secondary);
            border-radius: 8px;
            border: 1px solid var(--border-primary);
            overflow: hidden;
            transition: background-color 0.2s, border-color 0.2s;
        }

        .summary {
            padding: 20px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-primary);
            transition: background-color 0.2s, border-color 0.2s;
        }

        .summary h2 {
            margin: 0 0 15px 0;
            font-size: 1.5rem;
            color: var(--text-primary);
        }

        .person-summary {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            padding: 8px 12px;
            background: var(--bg-secondary);
            border-radius: 4px;
            border-left: 4px solid var(--border-summary);
            transition: background-color 0.2s;
            flex-wrap: wrap;
            gap: 8px;
        }

        .person-name {
            font-weight: 500;
            color: var(--text-primary);
            flex: 0 0 auto;
            white-space: nowrap;
        }

        .person-paid {
            color: var(--text-muted);
        }

        .person-total {
            color: var(--text-secondary);
            font-weight: 500;
            text-align: right;
            line-height: 1.3;
            min-width: 100px;
        }

        .settlements {
            padding: 20px;
        }

        .settlements h2 {
            margin: 0 0 15px 0;
            font-size: 1.5rem;
            color: var(--text-primary);
        }

        .settlement-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 15px;
            margin-bottom: 8px;
            background: var(--bg-accent);
            border-radius: 6px;
            border-left: 4px solid var(--border-accent);
            transition: background-color 0.2s;
        }

        .settlement-text {
            color: var(--text-accent);
            font-weight: 500;
        }

        .settlement-amount {
            color: var(--text-amount);
            font-weight: 600;
        }

        .no-data {
            padding: 40px;
            text-align: center;
            color: var(--text-muted);
            font-style: italic;
        }

        button {
            font-family: var(--font-family);
            background: var(--border-focus);
            color: black;
            border: none;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
        }

        button:hover {
            background: var(--border-total);
            transform: translateY(-1px);
        }

        button:active {
            transform: translateY(0);
        }

        .copy-button {
            margin-top: 15px;
            padding: 12px 24px;
            border-radius: 8px;
            display: block;
            margin-left: auto;
            margin-right: auto;
        }

        .copy-button.copied {
            background: var(--text-success);
        }

        .settle-button {
            padding: 6px 12px;
            border-radius: 4px;
            margin-left: 10px;
        }

        .settle-button.settled {
            background: var(--text-success);
            cursor: default;
        }

        @media (max-width: 768px) {
            .settle-text {
                display: none;
            }
        }
    </style>
</head>
<body>
    <textarea id="expenseInput" placeholder="Coloque nomes e despesas no seguinte formato:

David
18,11 Pedágio (por padrão dividido entre todos)
1.200,00 Hotel (pode usar ponto ou vírgula)

Ana
45 Restaurante (não precisa colocar centavos)
23 Lanche - David, Ana (dividido entre David e Ana)

Cristy
50 (descrição opcional)
125,75 Compras - C,A (pode usar somente iniciais)"></textarea>

    <div class="results" id="results">
        <div class="no-data">
            Adicione despesas acima para ver a divisão e acertos
        </div>
    </div>

    <button class="copy-button" id="copyButton" onclick="copyToClipboard()" style="display: none;">COPIAR RESUMO</button>

    <script>
        // Global error handler
        window.onerror = function(message, source, lineno, colno, error) {
            console.error('Global error caught:', message, error);
            const resultsDiv = document.getElementById('results');
            if (resultsDiv) {
                resultsDiv.innerHTML = '<div class="no-data">Erro: Por favor recarregue a página e tente novamente.</div>';
            }
            return true;
        };

        // Promise rejection handler
        window.addEventListener('unhandledrejection', function(event) {
            console.error('Unhandled promise rejection:', event.reason);
            const resultsDiv = document.getElementById('results');
            if (resultsDiv) {
                resultsDiv.innerHTML = '<div class="no-data">Erro: Por favor recarregue a página e tente novamente.</div>';
            }
            event.preventDefault();
        });

        let debounceTimer;
        let currentPeopleData = {};
        let currentSettlements = [];
        let currentSharedExpenses = [];

        function findPersonByNameOrInitial(nameOrInitial, allNames) {
            // First try exact match
            if (allNames.includes(nameOrInitial)) {
                return nameOrInitial;
            }

            // Then try partial match from the beginning
            const matches = allNames.filter(name =>
                name.toLowerCase().startsWith(nameOrInitial.toLowerCase().trim())
            );

            return matches.length === 1 ? matches[0] : null;
        }

        function parseSharedExpense(expenseLine, allNames) {
            // Look for pattern: amount description - person1, person2, person3
            const sharedMatch = expenseLine.match(/^(\d+(?:[.,]\d+)*(?:[.,]\d{1,2})?)(.+?)\s*-\s*(.+)$/);

            if (sharedMatch) {
                const amount = parseNumber(sharedMatch[1]);
                const description = sharedMatch[2].trim();
                const peopleStr = sharedMatch[3].trim();

                // Parse the people list
                const peopleNames = peopleStr.split(',').map(p => p.trim());
                const resolvedPeople = [];

                for (const personRef of peopleNames) {
                    const resolvedPerson = findPersonByNameOrInitial(personRef, allNames);
                    if (resolvedPerson) {
                        resolvedPeople.push(resolvedPerson);
                    }
                }

                if (!isNaN(amount) && amount >= 0 && resolvedPeople.length > 0) {
                    return {
                        amount: amount,
                        description: description,
                        sharedWith: resolvedPeople
                    };
                }
            }

            return null;
        }

        function parseNumber(numStr) {
            try {
                // Remove any leading/trailing whitespace
                numStr = numStr.trim();

                // If it's a simple integer with no separators
                if (/^\d+$/.test(numStr)) {
                    return parseFloat(numStr);
                }

                // Count dots and commas to determine format
                const dotCount = (numStr.match(/\./g) || []).length;
                const commaCount = (numStr.match(/,/g) || []).length;

                // If no separators at all, just parse as is
                if (dotCount === 0 && commaCount === 0) {
                    return parseFloat(numStr);
                }

                // Patterns for different formats
                const patterns = {
                    // European format: 1.234.567,89 or 1.234,89 or 123,89
                    european: /^\d{1,3}(?:\.\d{3})*,\d{1,2}$/,
                    // US format: 1,234,567.89 or 1,234.89 or 123.89
                    us: /^\d{1,3}(?:,\d{3})*\.\d{1,2}$/,
                    // Simple decimal with dot: 123.45
                    simpleDot: /^\d+\.\d{1,2}$/,
                    // Simple decimal with comma: 123,45
                    simpleComma: /^\d+,\d{1,2}$/,
                    // Thousands only with dots: 1.234 or 12.345
                    thousandsDot: /^\d{1,3}(?:\.\d{3})+$/,
                    // Thousands only with commas: 1,234 or 12,345
                    thousandsComma: /^\d{1,3}(?:,\d{3})+$/
                };

                // European format (1.234.567,89)
                if (patterns.european.test(numStr)) {
                    return parseFloat(numStr.replace(/\./g, '').replace(',', '.'));
                }

                // US format (1,234,567.89)
                if (patterns.us.test(numStr)) {
                    return parseFloat(numStr.replace(/,/g, ''));
                }

                // Simple decimal with dot (123.45)
                if (patterns.simpleDot.test(numStr)) {
                    return parseFloat(numStr);
                }

                // Simple decimal with comma (123,45)
                if (patterns.simpleComma.test(numStr)) {
                    return parseFloat(numStr.replace(',', '.'));
                }

                // Thousands only with dots (1.234) - assume European style
                if (patterns.thousandsDot.test(numStr)) {
                    return parseFloat(numStr.replace(/\./g, ''));
                }

                // Thousands only with commas (1,234) - assume US style
                if (patterns.thousandsComma.test(numStr)) {
                    return parseFloat(numStr.replace(/,/g, ''));
                }

                // Handle ambiguous cases based on position and context
                if (dotCount === 1 && commaCount === 0) {
                    // Could be decimal (12.50) or thousands (1.200)
                    const parts = numStr.split('.');
                    if (parts[1].length <= 2) {
                        // Likely decimal (12.50)
                        return parseFloat(numStr);
                    } else {
                        // Likely thousands (1.200)
                        return parseFloat(parts[0] + parts[1]);
                    }
                }

                if (commaCount === 1 && dotCount === 0) {
                    // Could be decimal (12,50) or thousands (1,200)
                    const parts = numStr.split(',');
                    if (parts[1].length <= 2) {
                        // Likely decimal (12,50)
                        return parseFloat(numStr.replace(',', '.'));
                    } else {
                        // Likely thousands (1,200)
                        return parseFloat(parts[0] + parts[1]);
                    }
                }

                // Mixed format detection - look at the last separator
                const lastDot = numStr.lastIndexOf('.');
                const lastComma = numStr.lastIndexOf(',');

                if (lastDot > lastComma) {
                    // Last separator is dot, assume US format
                    const beforeDot = numStr.substring(0, lastDot);
                    const afterDot = numStr.substring(lastDot + 1);

                    // If after dot is 1-2 digits, it's likely decimal
                    if (afterDot.length <= 2 && /^\d+$/.test(afterDot)) {
                        const cleanBefore = beforeDot.replace(/,/g, '');
                        return parseFloat(cleanBefore + '.' + afterDot);
                    }
                }

                if (lastComma > lastDot) {
                    // Last separator is comma, assume European format
                    const beforeComma = numStr.substring(0, lastComma);
                    const afterComma = numStr.substring(lastComma + 1);

                    // If after comma is 1-2 digits, it's likely decimal
                    if (afterComma.length <= 2 && /^\d+$/.test(afterComma)) {
                        const cleanBefore = beforeComma.replace(/\./g, '');
                        return parseFloat(cleanBefore + '.' + afterComma);
                    }
                }

                // Fallback: try to clean and parse
                const cleaned = numStr.replace(/[^\d.,]/g, '');
                if (cleaned.includes('.') && cleaned.includes(',')) {
                    // Both separators present, use heuristic
                    if (lastDot > lastComma) {
                        return parseFloat(cleaned.replace(/,/g, ''));
                    } else {
                        return parseFloat(cleaned.replace(/\./g, '').replace(',', '.'));
                    }
                } else if (cleaned.includes('.')) {
                    return parseFloat(cleaned.replace(',', '.'));
                } else if (cleaned.includes(',')) {
                    return parseFloat(cleaned.replace(',', '.'));
                } else {
                    return parseFloat(cleaned);
                }

            } catch (error) {
                console.error('Error parsing number:', numStr, error);
                return NaN;
            }
        }

        function formatNumber(amount) {
            try {
                // Use browser's locale for number formatting
                const locale = navigator.language || 'pt-BR';
                return amount.toLocaleString(locale, {
                    minimumFractionDigits: 2,
                    maximumFractionDigits: 2
                });
            } catch (error) {
                console.error('Error formatting number:', error);
                // Fallback to fixed decimal if locale formatting fails
                return amount.toFixed(2);
            }
        }

        function formatCurrency(amount) {
            try {
                // Format as currency using browser's locale
                const locale = navigator.language || 'pt-BR';
                return amount.toLocaleString(locale, {
                    style: 'currency',
                    currency: getCurrencyCode(locale),
                    minimumFractionDigits: 2,
                    maximumFractionDigits: 2
                });
            } catch (error) {
                console.error('Error formatting currency:', error);
                // Fallback to regular number formatting
                return formatNumber(amount);
            }
        }

        function getCurrencyCode(locale) {
            // Map common locales to currency codes
            const currencyMap = {
                'pt-BR': 'BRL',
                'pt-PT': 'EUR',
                'en-US': 'USD',
                'en-GB': 'GBP',
                'es-ES': 'EUR',
                'fr-FR': 'EUR',
                'de-DE': 'EUR',
                'it-IT': 'EUR'
            };

            return currencyMap[locale] || currencyMap[locale.split('-')[0]] || 'USD';
        }

        // Safely escape HTML characters in user input to prevent HTML injection
        // This function handles characters like <, >, &, and quotes
        function escapeHtml(text) {
            if (text == null || text === undefined) {
                return '';
            }
            const div = document.createElement('div');
            div.textContent = String(text);
            return div.innerHTML;
        }

        function parseExpenses(text) {
            try {
                const lines = text.split('\n').map(line => line.trim());
                const people = {};
                const sharedExpenses = [];
                let currentPerson = null;

                // First pass: collect all person names
                const allNames = [];
                for (const line of lines) {
                    if (line === '') continue;

                    const expenseMatch = line.match(/^(\d+(?:[.,]\d+)*(?:[.,]\d{1,2})?)/);
                    if (!expenseMatch && line.length > 0) {
                        allNames.push(line);
                    }
                }

                // Initialize people objects
                allNames.forEach(name => {
                    people[name] = {
                        expenses: [],
                        total: 0,
                        sharedExpenses: []
                    };
                });

                // Second pass: process expenses
                for (const line of lines) {
                    if (line === '') {
                        currentPerson = null;
                        continue;
                    }

                    // Enhanced regex to capture numbers with various formats
                    const expenseMatch = line.match(/^(\d+(?:[.,]\d+)*(?:[.,]\d{1,2})?)/);

                    if (expenseMatch && currentPerson) {
                        // Parse shared expense or default to all people
                        const sharedExpense = parseSharedExpense(line, allNames);
                        const amount = parseNumber(expenseMatch[1]);
                        const description = line.substring(expenseMatch[0].length).trim();

                        if (!isNaN(amount) && amount >= 0 && allNames.length > 0) {
                            let finalSharedExpense;

                            if (sharedExpense) {
                                // Use specific shared expense
                                finalSharedExpense = {
                                    ...sharedExpense,
                                    paidBy: currentPerson
                                };
                            } else {
                                // Default to shared by all people
                                finalSharedExpense = {
                                    amount: amount,
                                    description: description,
                                    sharedWith: allNames,
                                    paidBy: currentPerson
                                };
                            }

                            sharedExpenses.push(finalSharedExpense);

                            // Add the full amount to the person who paid
                            people[currentPerson].expenses.push({
                                amount: amount,
                                description: sharedExpense ? `${finalSharedExpense.description} - ${finalSharedExpense.sharedWith.join(', ')}` : description
                            });
                            people[currentPerson].total += amount;

                            // Track shared expenses for each participant (amounts will be calculated later)
                            finalSharedExpense.sharedWith.forEach(person => {
                                if (people[person]) {
                                    people[person].sharedExpenses.push({
                                        expense: finalSharedExpense,
                                        description: finalSharedExpense.description,
                                        paidBy: currentPerson
                                    });
                                }
                            });
                        }
                    } else if (!expenseMatch && line.length > 0) {
                        // This is a person's name
                        currentPerson = line;
                        if (!people[currentPerson]) {
                            people[currentPerson] = {
                                expenses: [],
                                total: 0,
                                sharedExpenses: []
                            };
                        }
                    }
                }

                return { people, sharedExpenses };
            } catch (error) {
                console.error('Error parsing expenses:', error);
                return { people: {}, sharedExpenses: [] };
            }
        }

        function calculateFairShares(names, sharedExpenses) {
            // Calculate total amounts each person owes across all shared expenses
            // This function now uses an improved algorithm that pools all remainder cents
            // and distributes them fairly among participants, rather than giving them
            // to whoever paid the expense. This ensures more equitable cent distribution.
            const totalOwed = {};
            names.forEach(name => {
                totalOwed[name] = 0;
            });

            // First pass: calculate base amounts and collect all remainders
            let totalRemainderCents = 0;
            const expenseDetails = [];

            sharedExpenses.forEach(expense => {
                const { amount, sharedWith } = expense;
                const amountCents = Math.round(amount * 100);
                const baseAmountCents = Math.floor(amountCents / sharedWith.length);
                const remainder = amountCents - (baseAmountCents * sharedWith.length);

                // Add base amount for each person in the shared group
                sharedWith.forEach(person => {
                    totalOwed[person] += baseAmountCents;
                });

                // Collect remainder for later distribution
                totalRemainderCents += remainder;
                expenseDetails.push({
                    expense,
                    remainder,
                    sharedWith
                });
            });

            // Second pass: distribute all remainder cents fairly
            // Instead of giving remainder cents to the payer, we pool all remainders
            // and distribute them based on participation frequency
            if (totalRemainderCents > 0) {
                // Create a list of all participants who should receive remainder cents
                const participantCounts = {};
                names.forEach(name => {
                    participantCounts[name] = 0;
                });

                // Count how many times each person appears in shared expenses
                expenseDetails.forEach(detail => {
                    detail.sharedWith.forEach(person => {
                        participantCounts[person]++;
                    });
                });

                // Sort people by their participation count (more participation = higher priority for remainder)
                const sortedParticipants = names
                    .filter(name => participantCounts[name] > 0)
                    .sort((a, b) => participantCounts[b] - participantCounts[a]);

                // Distribute remainder cents using round-robin among participants
                let remainderIndex = 0;
                while (totalRemainderCents > 0 && sortedParticipants.length > 0) {
                    const recipient = sortedParticipants[remainderIndex % sortedParticipants.length];
                    totalOwed[recipient] += 1;
                    totalRemainderCents--;
                    remainderIndex++;
                }
            }

            // Convert cents to dollars for final fair shares
            const fairShares = {};
            names.forEach(name => {
                fairShares[name] = totalOwed[name] / 100;
            });

            return fairShares;
        }

        function calculateSettlements(people, sharedExpenses) {
            try {
                const names = Object.keys(people);
                if (names.length === 0) return [];

                const fairShares = calculateFairShares(names, sharedExpenses);

                // Convert back to dollars and calculate balances
                const balances = {};
                names.forEach(name => {
                    balances[name] = 0;
                });

                // Calculate balances: what each person paid minus what they owe
                names.forEach(name => {
                    const totalPaid = people[name].total;
                    const totalShouldPay = fairShares[name];
                    balances[name] = totalPaid - totalShouldPay;
                });



                // Calculate settlements
                const settlements = [];
                const debtors = names.filter(name => balances[name] < -0.01).map(name => ({
                    name,
                    amount: Math.abs(balances[name])
                })).sort((a, b) => b.amount - a.amount);

                const creditors = names.filter(name => balances[name] > 0.01).map(name => ({
                    name,
                    amount: balances[name]
                })).sort((a, b) => b.amount - a.amount);

                let i = 0, j = 0;
                while (i < debtors.length && j < creditors.length) {
                    const debtor = debtors[i];
                    const creditor = creditors[j];
                    const amount = Math.min(debtor.amount, creditor.amount);

                    if (amount > 0.01) {
                        settlements.push({
                            from: debtor.name,
                            to: creditor.name,
                            amount: amount
                        });

                        debtor.amount -= amount;
                        creditor.amount -= amount;
                    }

                    if (debtor.amount < 0.01) i++;
                    if (creditor.amount < 0.01) j++;
                }

                return settlements;
            } catch (error) {
                console.error('Error calculating settlements:', error);
                return [];
            }
        }



        function generateTextSummary() {
            try {
                const names = Object.keys(currentPeopleData);
                if (names.length === 0) return '';

                const totalExpenses = names.reduce((sum, name) => {
                    return sum + (currentPeopleData[name] ? currentPeopleData[name].total || 0 : 0);
                }, 0);

                // Calculate fair shares using the helper function
                const fairShares = calculateFairShares(names, currentSharedExpenses);

                let text = '';

                // Calculate maximum width for amounts across all expenses
                let maxWidth = 0;
                names.forEach(name => {
                    const person = currentPeopleData[name];
                    if (person && person.expenses.length > 0) {
                        person.expenses.forEach(expense => {
                            const width = formatNumber(expense.amount).length;
                            if (width > maxWidth) maxWidth = width;
                        });
                    }
                });

                // Add parsed expenses by person
                text += '*GASTOS*\n';
                names.forEach(name => {
                    text += `${name}\n`;
                    const person = currentPeopleData[name];
                    if (person && person.expenses.length > 0) {
                        person.expenses.forEach(expense => {
                            const formattedAmount = formatNumber(expense.amount);
                            const paddedAmount = formattedAmount.padStart(maxWidth, ' ');
                            const description = expense.description ? ` ${expense.description}` : '';
                            text += ` ${paddedAmount}${description}\n`;
                        });
                    }
                    text += '\n';
                });

                // Add summary
                text += '*DIVISÃO*\n';
                names.forEach(name => {
                    const personTotal = currentPeopleData[name] ? currentPeopleData[name].total || 0 : 0;
                    const personShare = fairShares[name] || 0;
                    text += `${name} pagou ${formatNumber(personTotal)} de ${formatNumber(personShare)}\n`;
                });

                text += `\nTotal = ${formatNumber(totalExpenses)}\n`;

                // Add settlements
                text += '\n*ACERTOS*\n';
                if (totalExpenses === 0) {
                    text += 'Nenhum gasto para acertar\n';
                } else if (currentSettlements.length === 0) {
                    text += 'Todos estão quites!\n';
                } else {
                    currentSettlements.forEach(settlement => {
                        text += `${settlement.from} deve ${formatNumber(settlement.amount)} para ${settlement.to}\n`;
                    });
                }

                return text;
            } catch (error) {
                console.error('Error generating text summary:', error);
                return 'Erro ao gerar resumo';
            }
        }

        function copyToClipboard() {
            try {
                const textSummary = generateTextSummary();

                if (!textSummary) {
                    alert('Nada para copiar. Adicione alguns gastos primeiro.');
                    return;
                }

                // Try to use the modern clipboard API
                if (navigator.clipboard && window.isSecureContext) {
                    navigator.clipboard.writeText(textSummary).then(() => {
                        showCopySuccess();
                    }).catch(err => {
                        console.error('Failed to copy with clipboard API:', err);
                        fallbackCopy(textSummary);
                    });
                } else {
                    fallbackCopy(textSummary);
                }
            } catch (error) {
                console.error('Error copying to clipboard:', error);
                alert('Erro ao copiar. Tente novamente.');
            }
        }

        function fallbackCopy(text) {
            try {
                // Fallback method using textarea
                const textArea = document.createElement('textarea');
                textArea.value = text;
                textArea.style.position = 'fixed';
                textArea.style.left = '-999999px';
                textArea.style.top = '-999999px';
                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();

                const successful = document.execCommand('copy');
                document.body.removeChild(textArea);

                if (successful) {
                    showCopySuccess();
                } else {
                    alert('Não foi possível copiar automaticamente. Selecione e copie manualmente.');
                }
            } catch (err) {
                console.error('Fallback copy failed:', err);
                alert('Erro ao copiar. Tente selecionar e copiar manualmente.');
            }
        }

        function showCopySuccess() {
            const button = document.getElementById('copyButton');
            const originalText = button.textContent;
            button.textContent = 'COPIADO ✓';
            button.classList.add('copied');

            setTimeout(() => {
                button.textContent = originalText;
                button.classList.remove('copied');
            }, 2000);
        }

        function updateResults() {
            try {
                const input = document.getElementById('expenseInput').value;
                const resultsDiv = document.getElementById('results');
                const copyButton = document.getElementById('copyButton');

                if (!input.trim()) {
                    resultsDiv.innerHTML = '<div class="no-data">Adicione despesas acima para ver a divisão e acertos</div>';
                    copyButton.style.display = 'none';
                    currentPeopleData = {};
                    currentSettlements = [];
                    currentSharedExpenses = [];
                    return;
                }

                const { people, sharedExpenses } = parseExpenses(input);
                const names = Object.keys(people);

                if (names.length === 0) {
                    resultsDiv.innerHTML = '<div class="no-data">Nenhum nome válido encontrado</div>';
                    copyButton.style.display = 'none';
                    currentPeopleData = {};
                    currentSettlements = [];
                    currentSharedExpenses = [];
                    return;
                }

                // Store current data for copying
                currentPeopleData = people;
                currentSharedExpenses = sharedExpenses;
                currentSettlements = calculateSettlements(people, sharedExpenses);

                const totalExpenses = names.reduce((sum, name) => {
                    return sum + (people[name] ? people[name].total || 0 : 0);
                }, 0);

                // Calculate fair share amounts using the helper function
                const fairShares = calculateFairShares(names, sharedExpenses);

                let html = '<div class="summary">';

                // Show individual totals with fair shares
                names.forEach(name => {
                    const personTotal = people[name] ? people[name].total || 0 : 0;
                    const fairShare = fairShares[name] || 0;
                    html += `
                        <div class="person-summary">
                            <span class="person-name">
                              ${escapeHtml(name)}
                              <span class="person-paid">pagou ${formatNumber(personTotal)}</span>
                            </span>
                            <span class="person-total">${formatNumber(fairShare)}</span>
                        </div>
                    `;
                });

                html += `
                    <div class="person-summary" style="border-left-color: var(--border-total); font-weight: 600; margin-top: 10px;">
                        <span class="person-name">Total</span>
                        <span class="person-total">${formatNumber(totalExpenses)}</span>
                    </div>`;

                html += '</div>';

                // Show settlements
                html += '<div class="settlements">';

                if (totalExpenses === 0) {
                    html += '<div class="no-data">Nenhuma despesa para acertar</div>';
                } else if (currentSettlements.length === 0) {
                    html += '<div class="no-data">Tudo está acertado!</div>';
                } else {
                    currentSettlements.forEach((settlement, index) => {
                        html += `
                            <div class="settlement-item">
                                <span class="settlement-text">${escapeHtml(settlement.from)} deve ${formatNumber(settlement.amount)} para ${escapeHtml(settlement.to)}</span>
                                <button class="button-base settle-button" onclick="settlePayment(${index})">✓<span class="settle-text"> ACERTADO</span></button>
                            </div>
                        `;
                    });
                }

                html += '</div>';
                resultsDiv.innerHTML = html;

                // Show copy button when there are results
                copyButton.style.display = 'block';

            } catch (error) {
                console.error('Error updating results:', error);
                document.getElementById('results').innerHTML = '<div class="no-data">Erro ao processar os dados. Verifique o formato.</div>';
                document.getElementById('copyButton').style.display = 'none';
                currentPeopleData = {};
                currentSettlements = [];
                currentSharedExpenses = [];
            }
        }

        function settlePayment(settlementIndex) {
            try {
                const settlement = currentSettlements[settlementIndex];
                if (!settlement) return;

                const textarea = document.getElementById('expenseInput');
                const currentText = textarea.value;

                // Create the payment line in the format: "amount Acerto - recipient"
                const paymentLine = `${formatNumber(settlement.amount)} Acerto - ${settlement.to}`;

                // Find the payer's section and add the payment line
                const lines = currentText.split('\n');
                let payerIndex = -1;

                // Find where the payer's section starts
                for (let i = 0; i < lines.length; i++) {
                    if (lines[i].trim() === settlement.from) {
                        payerIndex = i;
                        break;
                    }
                }

                if (payerIndex !== -1) {
                    // Find the end of the payer's section (next person or end of file)
                    let insertIndex = lines.length;
                    let foundEmptyLine = false;

                    for (let i = payerIndex + 1; i < lines.length; i++) {
                        const line = lines[i].trim();

                        // If we find an empty line, mark it but continue looking
                        if (line === '') {
                            if (!foundEmptyLine) {
                                insertIndex = i;
                                foundEmptyLine = true;
                            }
                            continue;
                        }

                        // Check if this line is a person name (not an expense)
                        const expenseMatch = line.match(/^(\d+(?:[.,]\d+)*(?:[.,]\d{1,2})?)/);
                        if (!expenseMatch && line.length > 0) {
                            // This is a person name, insert before this line (or before the empty line if found)
                            if (!foundEmptyLine) {
                                insertIndex = i;
                            }
                            break;
                        }
                    }

                    // Insert the payment line
                    lines.splice(insertIndex, 0, paymentLine);

                    // Update the textarea
                    textarea.value = lines.join('\n');

                    // Save to localStorage after updating textarea
                    saveToLocalStorage();

                    // Mark button as settled
                    const buttons = document.querySelectorAll('.settle-button');
                    if (buttons[settlementIndex]) {
                        buttons[settlementIndex].textContent = '✓ Acertado';
                        buttons[settlementIndex].classList.add('settled');
                        buttons[settlementIndex].disabled = true;
                    }

                    // Trigger update after a small delay to show the change
                    setTimeout(() => {
                        updateResults();
                    }, 100);
                }
            } catch (error) {
                console.error('Error settling payment:', error);
                alert('Erro ao processar acerto. Tente novamente.');
            }
        }

        // Add debounced event listener with error handling
        document.getElementById('expenseInput').addEventListener('input', function() {
            try {
                // Auto-expand textarea first
                autoExpandTextarea(this);

                clearTimeout(debounceTimer);
                debounceTimer = setTimeout(() => {
                    try {
                        updateResults();
                        saveToLocalStorage(); // Save to localStorage after updating results
                    } catch (error) {
                        console.error('Error in updateResults:', error);
                        document.getElementById('results').innerHTML = '<div class="no-data">Erro ao processar os dados. Verifique o formato.</div>';
                        document.getElementById('copyButton').style.display = 'none';
                    }
                }, 300);
            } catch (error) {
                console.error('Error in input handler:', error);
            }
        });

        // Initial calculation with error handling
        try {
            updateResults();
        } catch (error) {
            console.error('Error in initial calculation:', error);
            document.getElementById('results').innerHTML = '<div class="no-data">Erro ao carregar a página. Por favor, recarregue.</div>';
        }
        // localStorage functions
        function saveToLocalStorage() {
            try {
                const textarea = document.getElementById('expenseInput');
                localStorage.setItem('expenseInputData', textarea.value);
            } catch (error) {
                console.error('Error saving to localStorage:', error);
            }
        }

        function loadFromLocalStorage() {
            try {
                const savedData = localStorage.getItem('expenseInputData');
                if (savedData) {
                    const textarea = document.getElementById('expenseInput');
                    textarea.value = savedData;
                    // Auto-expand after loading content
                    autoExpandTextarea(textarea);
                    // Update results after loading
                    updateResults();
                }
            } catch (error) {
                console.error('Error loading from localStorage:', error);
            }
        }

        // Load saved data when page loads
        // Auto-expanding textarea functionality
        function autoExpandTextarea(textarea) {
            // Reset height to measure the scroll height accurately
            textarea.style.height = 'auto';

            // Calculate new height, ensuring it stays within min/max bounds
            const minHeight = 300; // matches min-height in CSS
            const maxHeight = Math.floor(window.innerHeight * 0.6); // matches max-height: 60vh
            const newHeight = Math.max(minHeight, Math.min(textarea.scrollHeight, maxHeight));

            textarea.style.height = newHeight + 'px';
        }

        // Add paste event listener for auto-expand
        document.getElementById('expenseInput').addEventListener('paste', function() {
            // Use setTimeout to allow paste content to be processed first
            setTimeout(() => {
                autoExpandTextarea(this);
            }, 0);
        });

        // Handle window resize to recalculate max height
        window.addEventListener('resize', function() {
            const textarea = document.getElementById('expenseInput');
            if (textarea) {
                autoExpandTextarea(textarea);
            }
        });

        document.addEventListener('DOMContentLoaded', function() {
            loadFromLocalStorage();
            // Set initial height after loading
            const textarea = document.getElementById('expenseInput');
            if (textarea) {
                autoExpandTextarea(textarea);
            }
        });

    </script>
</body>
</html>
