<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Splitwiser Tests</title>
    <style>
        body {
            font-family: monospace;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .test-suite {
            background: white;
            margin: 10px 0;
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .test-suite h2 {
            margin-top: 0;
            color: #333;
            border-bottom: 2px solid #eee;
            padding-bottom: 5px;
        }
        .test-case {
            margin: 8px 0;
            padding: 5px;
            border-left: 3px solid #ddd;
            padding-left: 10px;
        }
        .test-case.pass {
            border-left-color: #4CAF50;
            background-color: #f1f8e9;
        }
        .test-case.fail {
            border-left-color: #f44336;
            background-color: #ffebee;
        }
        .test-name {
            font-weight: bold;
            margin-bottom: 3px;
            cursor: pointer;
            user-select: none;
        }
        .test-name:hover {
            text-decoration: underline;
        }
        .test-result {
            font-size: 0.9em;
            color: #666;
        }
        .test-error {
            color: #d32f2f;
            font-size: 0.9em;
            margin-top: 3px;
            cursor: pointer;
            user-select: none;
        }
        .test-error:hover {
            text-decoration: underline;
        }
        .summary {
            background: #333;
            color: white;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
            text-align: center;
        }
        .summary.all-pass {
            background: #4CAF50;
        }
        .summary.has-failures {
            background: #f44336;
            cursor: pointer;
        }
        .summary.has-failures:hover {
            background: #d32f2f;
        }

        @media (prefers-color-scheme: dark) {
            body {
                background-color: #1a1a1a;
                color: #e0e0e0;
            }
            .test-suite {
                background: #2d2d2d;
                box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            }
            .test-suite h2 {
                color: #e0e0e0;
                border-bottom-color: #444;
            }
            .test-case {
                border-left-color: #555;
            }
            .test-case.pass {
                background-color: #1b3d1b;
            }
            .test-case.fail {
                background-color: #3d1b1b;
            }
            .test-result {
                color: #b0b0b0;
            }
            .test-error {
                color: #ff6b6b;
            }
            .test-name:hover {
                text-decoration: underline;
            }
            .test-error:hover {
                text-decoration: underline;
            }
        }
    </style>
</head>
<body>
    <h1>Splitwiser Logic Tests</h1>
    <div id="summary" class="summary" onclick="scrollToFirstFailure()">
        <div id="summary-text">Running tests...</div>
    </div>
    <div id="test-results"></div>

    <script>
        // Generate dynamic version parameter to prevent caching during tests
        const testVersion = new Date().getTime();
    </script>
    <script src="locale.js" id="locale-script"></script>
    <script src="lib.js" id="lib-script"></script>
    <script>
        // Update script sources with dynamic version parameter
        document.getElementById('locale-script').src = `locale.js?v=${testVersion}`;
        document.getElementById('lib-script').src = `lib.js?v=${testVersion}`;
        
        // Force locale to 'en-US' for consistent test results
        // Store original navigator.language for locale-specific tests
        const originalNavigatorLanguage = navigator.language;
        Object.defineProperty(navigator, 'language', { 
            value: 'en-US', 
            configurable: true 
        });
        
        // Override LOCALE initialization to force 'en-US'
        window.addEventListener('load', () => {
            if (window.LOCALE) {
                LOCALE.currentLocale = 'en-US';
            }
        });
    </script>
    <script>
        // Simple test framework
        class TestFramework {
            constructor() {
                this.tests = [];
                this.currentSuite = null;
            }

            suite(name, fn) {
                this.currentSuite = { name, tests: [] };
                fn();
                this.tests.push(this.currentSuite);
                this.currentSuite = null;
            }

            test(name, fn) {
                if (!this.currentSuite) {
                    throw new Error('Test must be inside a suite');
                }
                this.currentSuite.tests.push({ name, fn });
            }

            assertEqual(actual, expected, message = '') {
                if (JSON.stringify(actual) !== JSON.stringify(expected)) {
                    throw new Error(`Expected ${JSON.stringify(expected)}, got ${JSON.stringify(actual)}. ${message}`);
                }
            }

            assertTrue(condition, message = '') {
                if (!condition) {
                    throw new Error(`Expected true, got false. ${message}`);
                }
            }

            assertFalse(condition, message = '') {
                if (condition) {
                    throw new Error(`Expected false, got true. ${message}`);
                }
            }

            assertThrows(fn, expectedMessage = '', message = '') {
                let errorThrown = false;
                let actualError = null;
                try {
                    fn();
                } catch (error) {
                    errorThrown = true;
                    actualError = error;
                    if (expectedMessage && !error.message.includes(expectedMessage)) {
                        throw new Error(`Expected error message to contain "${expectedMessage}", got "${error.message}". ${message}`);
                    }
                }
                if (!errorThrown) {
                    throw new Error(`Expected function to throw an error, but it didn't. ${message}`);
                }
                return actualError;
            }

            assertApproxEqual(actual, expected, tolerance = 0.01, message = '') {
                // Ensure tolerance is positive
                const absTolerance = Math.abs(tolerance);
                const difference = Math.abs(actual - expected);

                if (difference > absTolerance) {
                    throw new Error(`Expected approximately ${expected} (±${absTolerance}), got ${actual} (difference: ${difference}). ${message}`);
                }
            }

            run() {
                const resultsDiv = document.getElementById('test-results');
                const summaryDiv = document.getElementById('summary-text');
                let totalTests = 0;
                let passedTests = 0;

                this.tests.forEach(suite => {
                    const suiteDiv = document.createElement('div');
                    suiteDiv.className = 'test-suite';
                    suiteDiv.innerHTML = `<h2>${suite.name}</h2>`;

                    suite.tests.forEach(test => {
                        totalTests++;
                        const testDiv = document.createElement('div');
                        testDiv.className = 'test-case';

                        const nameDiv = document.createElement('div');
                        nameDiv.className = 'test-name';
                        nameDiv.textContent = test.name;
                        nameDiv.onclick = () => copyToClipboard(test.name);
                        testDiv.appendChild(nameDiv);

                        try {
                            test.fn();
                            testDiv.classList.add('pass');
                            const resultDiv = document.createElement('div');
                            resultDiv.className = 'test-result';
                            resultDiv.textContent = '✓ PASS';
                            testDiv.appendChild(resultDiv);
                            passedTests++;
                        } catch (error) {
                            testDiv.classList.add('fail');
                            testDiv.id = `test-fail-${totalTests}`;
                            const resultDiv = document.createElement('div');
                            resultDiv.className = 'test-result';
                            resultDiv.textContent = '✗ FAIL';
                            testDiv.appendChild(resultDiv);

                            const errorDiv = document.createElement('div');
                            errorDiv.className = 'test-error';
                            errorDiv.textContent = error.message;
                            errorDiv.onclick = () => copyToClipboard(`${test.name}\n✗ FAIL\n${error.message}`);
                            testDiv.appendChild(errorDiv);
                        }

                        suiteDiv.appendChild(testDiv);
                    });

                    resultsDiv.appendChild(suiteDiv);
                });

                // Update summary
                const summaryElement = document.getElementById('summary');
                if (passedTests === totalTests) {
                    summaryElement.className = 'summary all-pass';
                    summaryDiv.textContent = `All ${totalTests} tests passed! ✓`;
                } else {
                    summaryElement.className = 'summary has-failures';
                    summaryDiv.textContent = `${passedTests}/${totalTests} tests passed. ${totalTests - passedTests} failures.`;
                }
            }
        }

        const test = new TestFramework();

        function scrollToFirstFailure() {
            const firstFailure = document.querySelector('.test-case.fail');
            if (firstFailure) {
                firstFailure.scrollIntoView({ behavior: 'auto', block: 'start' });
            }
        }



        // NumberLogic Tests
        test.suite('NumberLogic.parseNumber', () => {
            test.test('parses simple integers', () => {
                test.assertEqual(NumberLogic.parseNumber('123'), 123);
                test.assertEqual(NumberLogic.parseNumber('0'), 0);
            });

            test.test('parses US format decimals', () => {
                test.assertEqual(NumberLogic.parseNumber('123.45'), 123.45);
                test.assertEqual(NumberLogic.parseNumber('0.99'), 0.99);
            });

            test.test('parses European format decimals', () => {
                test.assertEqual(NumberLogic.parseNumber('123,45'), 123.45);
                test.assertEqual(NumberLogic.parseNumber('0,99'), 0.99);
            });

            test.test('parses US format with thousands separator', () => {
                test.assertEqual(NumberLogic.parseNumber('1,234.56'), 1234.56);
                test.assertEqual(NumberLogic.parseNumber('12,345'), 12345);
            });

            test.test('parses European format with thousands separator', () => {
                test.assertEqual(NumberLogic.parseNumber('1.234,56'), 1234.56);
                test.assertEqual(NumberLogic.parseNumber('12.345'), 12345);
            });

            test.test('handles edge cases', () => {
                test.assertTrue(isNaN(NumberLogic.parseNumber('')));
                test.assertTrue(isNaN(NumberLogic.parseNumber('abc')));
                test.assertEqual(NumberLogic.parseNumber('  123.45  '), 123.45);
            });
        });

        test.suite('NumberLogic.formatNumber', () => {
            // Use stored original language for locale-specific tests
            const originalLanguage = originalNavigatorLanguage;

            test.test('formats integers with decimals', () => {
                Object.defineProperty(navigator, 'language', { value: 'en-US', configurable: true });
                test.assertEqual(NumberLogic.formatNumber(123), '123.00', navigator.language);

                Object.defineProperty(navigator, 'language', { value: 'pt-BR', configurable: true });
                test.assertEqual(NumberLogic.formatNumber(123), '123,00', navigator.language);

                Object.defineProperty(navigator, 'language', { value: 'es-ES', configurable: true });
                test.assertEqual(NumberLogic.formatNumber(123), '123,00', navigator.language);
            });

            test.test('formats decimals', () => {
                Object.defineProperty(navigator, 'language', { value: 'en-US', configurable: true });
                test.assertEqual(NumberLogic.formatNumber(123.45), '123.45', navigator.language);

                Object.defineProperty(navigator, 'language', { value: 'pt-BR', configurable: true });
                test.assertEqual(NumberLogic.formatNumber(123.45), '123,45', navigator.language);

                Object.defineProperty(navigator, 'language', { value: 'es-ES', configurable: true });
                test.assertEqual(NumberLogic.formatNumber(123.45), '123,45', navigator.language);
            });

            test.test('formats large numbers with thousands separator', () => {
                Object.defineProperty(navigator, 'language', { value: 'en-US', configurable: true });
                test.assertEqual(NumberLogic.formatNumber(1234.56), '1,234.56', navigator.language);

                Object.defineProperty(navigator, 'language', { value: 'pt-BR', configurable: true });
                test.assertEqual(NumberLogic.formatNumber(1234.56), '1.234,56', navigator.language);

                Object.defineProperty(navigator, 'language', { value: 'es-ES', configurable: true });
                test.assertEqual(NumberLogic.formatNumber(1234.56), '1234,56', navigator.language);
            });

            test.test('handles zero', () => {
                Object.defineProperty(navigator, 'language', { value: 'en-US', configurable: true });
                test.assertEqual(NumberLogic.formatNumber(0), '0.00', navigator.language);

                Object.defineProperty(navigator, 'language', { value: 'pt-BR', configurable: true });
                test.assertEqual(NumberLogic.formatNumber(0), '0,00', navigator.language);

                Object.defineProperty(navigator, 'language', { value: 'es-ES', configurable: true });
                test.assertEqual(NumberLogic.formatNumber(0), '0,00', navigator.language);
            });

            test.test('handles negative zero', () => {
                Object.defineProperty(navigator, 'language', { value: 'en-US', configurable: true });
                test.assertEqual(NumberLogic.formatNumber(-0), '0.00', navigator.language);

                Object.defineProperty(navigator, 'language', { value: 'pt-BR', configurable: true });
                test.assertEqual(NumberLogic.formatNumber(-0), '0,00', navigator.language);

                Object.defineProperty(navigator, 'language', { value: 'es-ES', configurable: true });
                test.assertEqual(NumberLogic.formatNumber(-0), '0,00', navigator.language);
            });

            test.test('handles small decimals', () => {
                Object.defineProperty(navigator, 'language', { value: 'en-US', configurable: true });
                test.assertEqual(NumberLogic.formatNumber(0.99), '0.99', navigator.language);

                Object.defineProperty(navigator, 'language', { value: 'pt-BR', configurable: true });
                test.assertEqual(NumberLogic.formatNumber(0.99), '0,99', navigator.language);

                Object.defineProperty(navigator, 'language', { value: 'es-ES', configurable: true });
                test.assertEqual(NumberLogic.formatNumber(0.99), '0,99', navigator.language);
            });

            test.test('rounds to two decimal places', () => {
                Object.defineProperty(navigator, 'language', { value: 'en-US', configurable: true });
                test.assertEqual(NumberLogic.formatNumber(123.456), '123.46', navigator.language);

                Object.defineProperty(navigator, 'language', { value: 'pt-BR', configurable: true });
                test.assertEqual(NumberLogic.formatNumber(123.456), '123,46', navigator.language);

                Object.defineProperty(navigator, 'language', { value: 'es-ES', configurable: true });
                test.assertEqual(NumberLogic.formatNumber(123.456), '123,46', navigator.language);
            });

            test.test('handles negative numbers', () => {
                Object.defineProperty(navigator, 'language', { value: 'en-US', configurable: true });
                test.assertEqual(NumberLogic.formatNumber(-123.45), '-123.45', navigator.language);

                Object.defineProperty(navigator, 'language', { value: 'pt-BR', configurable: true });
                test.assertEqual(NumberLogic.formatNumber(-123.45), '-123,45', navigator.language);

                Object.defineProperty(navigator, 'language', { value: 'es-ES', configurable: true });
                test.assertEqual(NumberLogic.formatNumber(-123.45), '-123,45', navigator.language);
            });

            // Restore original language after tests
            test.test('cleanup', () => {
                Object.defineProperty(navigator, 'language', { value: originalLanguage, configurable: true });
                test.assertTrue(true); // Just a cleanup test
            });
        });

        test.suite('PersonLogic.parsePersonName', () => {
            test.test('parses simple name', () => {
                const result = PersonLogic.parsePersonName('John');
                test.assertEqual(result.displayName, 'John');
                test.assertEqual(result.baseName, 'John');
                test.assertEqual(result.parts, 1);
                test.assertFalse(result.isExcluded);
            });

            test.test('parses name with parts', () => {
                const result = PersonLogic.parsePersonName('John 3');
                test.assertEqual(result.displayName, 'John');
                test.assertEqual(result.baseName, 'John');
                test.assertEqual(result.parts, 3);
                test.assertFalse(result.isExcluded);
            });

            test.test('parses name with parentheses parts', () => {
                const result = PersonLogic.parsePersonName('John (2)');
                test.assertEqual(result.displayName, 'John');
                test.assertEqual(result.baseName, 'John');
                test.assertEqual(result.parts, 2);
                test.assertFalse(result.isExcluded);
            });

            test.test('parses excluded name', () => {
                const result = PersonLogic.parsePersonName('John!');
                test.assertEqual(result.displayName, 'John!');
                test.assertEqual(result.baseName, 'John');
                test.assertEqual(result.parts, 1);
                test.assertTrue(result.isExcluded);
            });

            test.test('parses excluded name with parts', () => {
                const result = PersonLogic.parsePersonName('John! 2');
                test.assertEqual(result.displayName, 'John!');
                test.assertEqual(result.baseName, 'John');
                test.assertEqual(result.parts, 2);
                test.assertTrue(result.isExcluded);
            });

            test.test('handles complex names', () => {
                const result = PersonLogic.parsePersonName('Mary Jane 4');
                test.assertEqual(result.displayName, 'Mary Jane');
                test.assertEqual(result.baseName, 'Mary Jane');
                test.assertEqual(result.parts, 4);
                test.assertFalse(result.isExcluded);
            });
        });

        test.suite('ValidationLogic.validatePersonReference', () => {
            const people = ['John', 'Jane', 'Jack'];
            const personData = {
                'John': { displayName: 'John' },
                'Jane': { displayName: 'Jane' },
                'Jack': { displayName: 'Jack' }
            };

            test.test('validates exact match', () => {
                const result = ValidationLogic.validatePersonReference('John', people, personData);
                test.assertTrue(result.isValid);
                test.assertEqual(result.matches, ['John']);
                test.assertFalse(result.isAmbiguous);
                test.assertFalse(result.notFound);
            });

            test.test('validates partial match', () => {
                const result = ValidationLogic.validatePersonReference('Jo', people, personData);
                test.assertTrue(result.isValid);
                test.assertEqual(result.matches, ['John']);
            });

            test.test('detects ambiguous match', () => {
                const result = ValidationLogic.validatePersonReference('Ja', people, personData);
                test.assertFalse(result.isValid);
                test.assertTrue(result.isAmbiguous);
                test.assertEqual(result.matches.sort(), ['Jack', 'Jane'].sort());
            });

            test.test('detects not found', () => {
                const result = ValidationLogic.validatePersonReference('Bob', people, personData);
                test.assertFalse(result.isValid);
                test.assertTrue(result.notFound);
                test.assertEqual(result.matches, []);
            });

            test.test('handles empty reference', () => {
                const result = ValidationLogic.validatePersonReference('', people, personData);
                test.assertTrue(result.isValid);
                test.assertEqual(result.matches, []);
            });
        });

        test.suite('TransactionLogic.parseTransaction', () => {
            const allNames = ['John', 'Jane', 'Alice', 'David'];
            const personData = {
                'John': { displayName: 'John' },
                'Jane': { displayName: 'Jane' },
                'Alice': { displayName: 'Alice' },
                'David': { displayName: 'David' }
            };

            test.test('parses basic expense', () => {
                const result = TransactionLogic.parseTransaction('50 Dinner', allNames, personData);
                test.assertEqual(result.type, 'expense');
                test.assertEqual(result.amount, 50);
                test.assertEqual(result.description, 'Dinner');
                test.assertEqual(result.sharedWith, []);
            });

            test.test('parses expense with participants', () => {
                const result = TransactionLogic.parseTransaction('30 Lunch - John, Jane', allNames, personData);
                test.assertEqual(result.type, 'expense');
                test.assertEqual(result.amount, 30);
                test.assertEqual(result.description, 'Lunch');
                test.assertEqual(result.sharedWith, ['John', 'Jane']);
            });

            test.test('parses expense with initials for participants', () => {
                const result = TransactionLogic.parseTransaction('20 Lunch - A,D', allNames, personData);
                test.assertEqual(result.type, 'expense');
                test.assertEqual(result.amount, 20);
                test.assertEqual(result.description, 'Lunch');
                test.assertEqual(result.sharedWith, ['Alice', 'David']);
            });

            test.test('parses percentage fee', () => {
                const result = TransactionLogic.parseTransaction('10% Service fee', allNames, personData);
                test.assertEqual(result.type, 'percentage');
                test.assertEqual(result.percentage, 10);
                test.assertEqual(result.description, 'Service fee');
                test.assertEqual(result.sharedWith, []);
            });

            test.test('parses percentage fee without description', () => {
                const result = TransactionLogic.parseTransaction('15%', allNames, personData);
                test.assertEqual(result.type, 'percentage');
                test.assertEqual(result.percentage, 15);
                test.assertEqual(result.description, '');
                test.assertEqual(result.sharedWith, []);
            });

            test.test('parses settlement', () => {
                const result = TransactionLogic.parseTransaction('25 > John', allNames, personData);
                test.assertEqual(result.type, 'settlement');
                test.assertEqual(result.amount, 25);
                test.assertEqual(result.settleTo, 'John');
            });

            test.test('handles invalid input', () => {
                const result = TransactionLogic.parseTransaction('invalid', allNames, personData);
                test.assertEqual(result, null);
            });

            test.test('parses amount only', () => {
                const result = TransactionLogic.parseTransaction('75', allNames, personData);
                test.assertEqual(result.type, 'expense');
                test.assertEqual(result.amount, 75);
                test.assertEqual(result.description, '');
            });
        });

        test.suite('CalculationLogic', () => {
            test.test('calculateTotalExpenses with basic expenses', () => {
                const transactions = [
                    { type: 'expense', amount: 50 },
                    { type: 'expense', amount: 30 },
                    { type: 'settlement', amount: 20 }
                ];
                const result = CalculationLogic.calculateTotalExpenses(transactions);
                test.assertEqual(result, 80);
            });

            test.test('calculateTotalExpenses with percentage fees', () => {
                const transactions = [
                    { type: 'expense', amount: 100 },
                    { type: 'percentage', percentage: 10 }
                ];
                const result = CalculationLogic.calculateTotalExpenses(transactions);
                test.assertEqual(result, 110);
            });

            test.test('calculateFairShares with equal parts', () => {
                const names = ['John', 'Jane'];
                const transactions = [
                    { type: 'expense', amount: 100, sharedWith: [] }
                ];
                const peopleData = {
                    'John': { parts: 1, isExcluded: false },
                    'Jane': { parts: 1, isExcluded: false }
                };
                const result = CalculationLogic.calculateFairShares(names, transactions, peopleData);
                test.assertEqual(result.John, 50);
                test.assertEqual(result.Jane, 50);
            });

            test.test('calculateFairShares with different parts', () => {
                const names = ['John', 'Jane'];
                const transactions = [
                    { type: 'expense', amount: 100, sharedWith: [] }
                ];
                const peopleData = {
                    'John': { parts: 2, isExcluded: false },
                    'Jane': { parts: 1, isExcluded: false }
                };
                const result = CalculationLogic.calculateFairShares(names, transactions, peopleData);
                test.assertApproxEqual(result.John, 66.67, 0.02); // Increased tolerance for floating-point precision (100*2/3)
                test.assertApproxEqual(result.Jane, 33.33, 0.02); // Increased tolerance for floating-point precision (100*1/3)
            });

            test.test('calculateFairShares excludes excluded people', () => {
                const names = ['John', 'Jane', 'Restaurant'];
                const transactions = [
                    { type: 'expense', amount: 100, sharedWith: [] }
                ];
                const peopleData = {
                    'John': { parts: 1, isExcluded: false },
                    'Jane': { parts: 1, isExcluded: false },
                    'Restaurant': { parts: 1, isExcluded: true }
                };
                const result = CalculationLogic.calculateFairShares(names, transactions, peopleData);
                test.assertEqual(result.John, 50);
                test.assertEqual(result.Jane, 50);
                test.assertEqual(result.Restaurant, 0);
            });

            test.test('getExpenseTransactions filters correctly', () => {
                const transactions = [
                    { type: 'expense', amount: 50 },
                    { type: 'settlement', amount: 20 },
                    { type: 'percentage', percentage: 10 }
                ];
                const result = CalculationLogic.getExpenseTransactions(transactions);
                test.assertEqual(result.length, 1);
                test.assertEqual(result[0].amount, 50);
            });

            test.test('getSettlementTransactions filters correctly', () => {
                const transactions = [
                    { type: 'expense', amount: 50 },
                    { type: 'settlement', amount: 20 },
                    { type: 'percentage', percentage: 10 }
                ];
                const result = CalculationLogic.getSettlementTransactions(transactions);
                test.assertEqual(result.length, 1);
                test.assertEqual(result[0].amount, 20);
            });

            test.test('getPercentageTransactions filters correctly', () => {
                const transactions = [
                    { type: 'expense', amount: 50 },
                    { type: 'settlement', amount: 20 },
                    { type: 'percentage', percentage: 10 }
                ];
                const result = CalculationLogic.getPercentageTransactions(transactions);
                test.assertEqual(result.length, 1);
                test.assertEqual(result[0].percentage, 10);
            });
        });

        test.suite('CalculationLogic with specific sharedWith participants', () => {
            test.test('calculateFairShares with expense shared by specific people', () => {
                const names = ['John', 'Jane', 'Bob'];
                const transactions = [
                    { type: 'expense', amount: 60, sharedWith: ['John', 'Jane'] }
                ];
                const peopleData = {
                    'John': { parts: 1, isExcluded: false },
                    'Jane': { parts: 1, isExcluded: false },
                    'Bob': { parts: 1, isExcluded: false }
                };
                const result = CalculationLogic.calculateFairShares(names, transactions, peopleData);
                test.assertEqual(result.John, 30);
                test.assertEqual(result.Jane, 30);
                test.assertEqual(result.Bob, 0);
            });

            test.test('calculateFairShares with expense shared by specific people with different parts', () => {
                const names = ['John', 'Jane', 'Bob'];
                const transactions = [
                    { type: 'expense', amount: 90, sharedWith: ['John', 'Jane'] }
                ];
                const peopleData = {
                    'John': { parts: 2, isExcluded: false },
                    'Jane': { parts: 1, isExcluded: false },
                    'Bob': { parts: 1, isExcluded: false }
                };
                const result = CalculationLogic.calculateFairShares(names, transactions, peopleData);
                test.assertEqual(result.John, 60);
                test.assertEqual(result.Jane, 30);
                test.assertEqual(result.Bob, 0);
            });

            test.test('calculateFairShares with multiple expenses with different participants', () => {
                const names = ['John', 'Jane', 'Bob', 'Alice'];
                const transactions = [
                    { type: 'expense', amount: 100, sharedWith: ['John', 'Jane'] },
                    { type: 'expense', amount: 60, sharedWith: ['Bob', 'Alice'] },
                    { type: 'expense', amount: 80, sharedWith: ['John', 'Bob', 'Alice'] }
                ];
                const peopleData = {
                    'John': { parts: 1, isExcluded: false },
                    'Jane': { parts: 1, isExcluded: false },
                    'Bob': { parts: 1, isExcluded: false },
                    'Alice': { parts: 1, isExcluded: false }
                };
                const result = CalculationLogic.calculateFairShares(names, transactions, peopleData);
                test.assertApproxEqual(result.John, 76.67, 0.02); // 50 + 26.67 (increased tolerance for floating-point precision)
                test.assertEqual(result.Jane, 50); // 50 only
                test.assertApproxEqual(result.Bob, 56.67, 0.02); // 30 + 26.67 (increased tolerance for floating-point precision)
                test.assertApproxEqual(result.Alice, 56.67, 0.02); // 30 + 26.67 (increased tolerance for floating-point precision)
            });

            test.test('calculateFairShares with percentage fee applied to specific participants', () => {
                const names = ['John', 'Jane', 'Bob'];
                const transactions = [
                    { type: 'expense', amount: 100, sharedWith: ['John', 'Jane'] },
                    { type: 'percentage', percentage: 10, sharedWith: ['John', 'Jane'] }
                ];
                const peopleData = {
                    'John': { parts: 1, isExcluded: false },
                    'Jane': { parts: 1, isExcluded: false },
                    'Bob': { parts: 1, isExcluded: false }
                };
                const result = CalculationLogic.calculateFairShares(names, transactions, peopleData);
                test.assertEqual(result.John, 55); // 50 + 10% of 50
                test.assertEqual(result.Jane, 55); // 50 + 10% of 50
                test.assertEqual(result.Bob, 0); // Not included in either
            });

            test.test('calculateFairShares with mixed shared and all-participant expenses', () => {
                const names = ['John', 'Jane', 'Bob'];
                const transactions = [
                    { type: 'expense', amount: 90, sharedWith: [] }, // All participants
                    { type: 'expense', amount: 60, sharedWith: ['John', 'Jane'] } // Specific participants
                ];
                const peopleData = {
                    'John': { parts: 1, isExcluded: false },
                    'Jane': { parts: 1, isExcluded: false },
                    'Bob': { parts: 1, isExcluded: false }
                };
                const result = CalculationLogic.calculateFairShares(names, transactions, peopleData);
                test.assertEqual(result.John, 60); // 30 (from 90/3) + 30 (from 60/2)
                test.assertEqual(result.Jane, 60); // 30 (from 90/3) + 30 (from 60/2)
                test.assertEqual(result.Bob, 30); // 30 (from 90/3) + 0 (not in specific expense)
            });

            test.test('calculateFairShares excludes excluded people from all-participant expenses but not specific ones', () => {
                const names = ['John', 'Jane', 'Restaurant'];
                const transactions = [
                    { type: 'expense', amount: 100, sharedWith: [] }, // All participants (should exclude Restaurant)
                    { type: 'expense', amount: 20, sharedWith: ['John', 'Restaurant'] } // Specific participants (should include Restaurant)
                ];
                const peopleData = {
                    'John': { parts: 1, isExcluded: false },
                    'Jane': { parts: 1, isExcluded: false },
                    'Restaurant': { parts: 1, isExcluded: true }
                };
                const result = CalculationLogic.calculateFairShares(names, transactions, peopleData);
                test.assertEqual(result.John, 60); // 50 (from 100/2) + 10 (from 20/2)
                test.assertEqual(result.Jane, 50); // 50 (from 100/2) + 0 (not in specific expense)
                test.assertEqual(result.Restaurant, 10); // 0 (excluded from all-participant) + 10 (from 20/2)
            });

            test.test('calculateFairShares with single participant expense', () => {
                const names = ['John', 'Jane', 'Bob'];
                const transactions = [
                    { type: 'expense', amount: 45, sharedWith: ['John'] }
                ];
                const peopleData = {
                    'John': { parts: 1, isExcluded: false },
                    'Jane': { parts: 1, isExcluded: false },
                    'Bob': { parts: 1, isExcluded: false }
                };
                const result = CalculationLogic.calculateFairShares(names, transactions, peopleData);
                test.assertEqual(result.John, 45);
                test.assertEqual(result.Jane, 0);
                test.assertEqual(result.Bob, 0);
            });

            test.test('calculateFairShares with percentage fee on single participant', () => {
                const names = ['John', 'Jane', 'Bob'];
                const transactions = [
                    { type: 'expense', amount: 100, sharedWith: ['John'] },
                    { type: 'percentage', percentage: 15, sharedWith: ['John'] }
                ];
                const peopleData = {
                    'John': { parts: 1, isExcluded: false },
                    'Jane': { parts: 1, isExcluded: false },
                    'Bob': { parts: 1, isExcluded: false }
                };
                const result = CalculationLogic.calculateFairShares(names, transactions, peopleData);
                test.assertEqual(result.John, 115); // 100 + 15% of 100
                test.assertEqual(result.Jane, 0);
                test.assertEqual(result.Bob, 0);
            });
        });

        test.suite('ExpenseLogic.parseExpenses - Complete User Input', () => {
            test.test('parses simple expense list with names and amounts', () => {
                const input = `
John
50 Dinner
30 Lunch

Jane
25 Coffee
15 Snacks`;

                const result = ExpenseLogic.parseExpenses(input);

                test.assertEqual(Object.keys(result.people).length, 2);
                test.assertEqual(result.people['John'].expenses.length, 2);
                test.assertEqual(result.people['Jane'].expenses.length, 2);
                test.assertEqual(result.people['John'].total, 80);
                test.assertEqual(result.people['Jane'].total, 40);
            });

            test.test('parses expenses with descriptions', () => {
                const input = `
Alice
100 Restaurant dinner
25.50 Taxi ride
15 Coffee shop`;

                const result = ExpenseLogic.parseExpenses(input);

                test.assertEqual(result.people['Alice'].expenses.length, 3);
                test.assertEqual(result.people['Alice'].expenses[0].description, 'Restaurant dinner');
                test.assertEqual(result.people['Alice'].expenses[1].description, 'Taxi ride');
                test.assertEqual(result.people['Alice'].expenses[2].description, 'Coffee shop');
                test.assertApproxEqual(result.people['Alice'].total, 140.50, 0.01);
            });

            test.test('parses expenses with specific participants', () => {
                const input = `
John
60 Dinner - Jane, Bob
30 Lunch

Jane

Bob`;

                const result = ExpenseLogic.parseExpenses(input);

                test.assertEqual(result.transactions.length, 2);
                test.assertEqual(result.transactions[0].sharedWith, ['Jane', 'Bob']);
                test.assertEqual(result.transactions[1].sharedWith, []);
            });

            test.test('parses expenses with person parts', () => {
                const input = `
John 2
90 Hotel room

Jane

Bob (3)`;

                const result = ExpenseLogic.parseExpenses(input);

                test.assertEqual(result.people['John 2'].parts, 2);
                test.assertEqual(result.people['Jane'].parts, 1);
                test.assertEqual(result.people['Bob (3)'].parts, 3);
            });

            test.test('parses expenses with excluded persons', () => {
                const input = `
John
100 Dinner
20 Tip

Jane!

Restaurant!`;

                const result = ExpenseLogic.parseExpenses(input);

                test.assertFalse(result.people['John'].isExcluded);
                test.assertTrue(result.people['Jane!'].isExcluded);
                test.assertTrue(result.people['Restaurant!'].isExcluded);
            });

            test.test('parses settlements', () => {
                const input = `
John
50 > Jane
25 Dinner

Jane`;

                const result = ExpenseLogic.parseExpenses(input);

                test.assertEqual(result.transactions.length, 2);
                test.assertEqual(result.transactions[0].type, 'settlement');
                test.assertEqual(result.transactions[0].settleTo, 'Jane');
                test.assertEqual(result.transactions[1].type, 'expense');
            });

            test.test('parses percentage fees', () => {
                const input = `
John
100 Dinner
10% Service fee
5% Tax

Jane`;

                const result = ExpenseLogic.parseExpenses(input);

                test.assertEqual(result.transactions.length, 3);
                test.assertEqual(result.transactions[1].type, 'percentage');
                test.assertEqual(result.transactions[1].percentage, 10);
                test.assertEqual(result.transactions[2].type, 'percentage');
                test.assertEqual(result.transactions[2].percentage, 5);
            });

            test.test('parses mixed European and US number formats', () => {
                const input = `
John
1,234.56 Expensive dinner
123,45 European format
1.234 Thousands only`;

                const result = ExpenseLogic.parseExpenses(input);

                test.assertEqual(result.people['John'].expenses.length, 3);
                test.assertApproxEqual(result.people['John'].expenses[0].amount, 1234.56, 0.01);
                test.assertApproxEqual(result.people['John'].expenses[1].amount, 123.45, 0.01);
                test.assertEqual(result.people['John'].expenses[2].amount, 1234);
            });

            test.test('handles non-validation invalid inputs gracefully', () => {
                const input = `
John
@invalid line
50 Valid expense
Jane
-50 Invalid amount
25 Valid expense`;

                const result = ExpenseLogic.parseExpenses(input);

                // Should parse valid parts and ignore invalid lines
                test.assertEqual(result.people['John'].expenses.length, 1);
                test.assertEqual(result.people['Jane'].expenses.length, 1);
                test.assertEqual(result.people['John'].total, 50);
                test.assertEqual(result.people['Jane'].total, 25);
            });

            test.test('parses complex real-world scenario', () => {
                const input = `
John 2
150 Hotel room - John, Jane
45.50 Taxi to airport
25 > Jane

Jane
80 Dinner - John, Jane, Bob
12% Service fee - John, Jane, Bob
30 Coffee

Bob!
20 > Restaurant

Restaurant!`;

                const result = ExpenseLogic.parseExpenses(input);

                // Check people setup
                test.assertEqual(Object.keys(result.people).length, 4);
                test.assertEqual(result.people['John 2'].parts, 2);
                test.assertTrue(result.people['Bob!'].isExcluded);
                test.assertTrue(result.people['Restaurant!'].isExcluded);

                // Check transactions
                test.assertEqual(result.transactions.length, 7);

                // Check specific transaction types
                const expenseTransactions = result.transactions.filter(t => t.type === 'expense');
                const settlementTransactions = result.transactions.filter(t => t.type === 'settlement');
                const percentageTransactions = result.transactions.filter(t => t.type === 'percentage');

                test.assertEqual(expenseTransactions.length, 4);
                test.assertEqual(settlementTransactions.length, 2);
                test.assertEqual(percentageTransactions.length, 1);
            });

            test.test('handles empty lines and whitespace', () => {
                const input = `
John

50 Dinner


Jane

25 Coffee

30 Lunch

`;

                const result = ExpenseLogic.parseExpenses(input);

                test.assertEqual(Object.keys(result.people).length, 2);
                test.assertEqual(result.people['John'].expenses.length, 1);
                test.assertEqual(result.people['Jane'].expenses.length, 2);
            });

            test.test('parses initials in participant lists', () => {
                const input = `
John Smith
60 Dinner - Jo, Bo
30 Lunch - Jane

Jane Doe

Bob Wilson`;

                const result = ExpenseLogic.parseExpenses(input);

                test.assertEqual(result.transactions[0].sharedWith.length, 2);
                test.assertEqual(result.transactions[1].sharedWith, ['Jane Doe']);
            });
        });

        test.suite('ValidationLogic.validateExpenses - Invalid Input Detection', () => {
            test.test('detects duplicate person names', () => {
                const input = `
John
Jane
john
Jane`;

                const warnings = ValidationLogic.validateExpenses(input);

                test.assertEqual(warnings.length, 2);
                test.assertTrue(warnings[0].error.includes('duplicate'));
                test.assertTrue(warnings[1].error.includes('duplicate'));
            });

            test.test('detects ambiguous person references in expenses', () => {
                const input = `
John Smith
50 Dinner - J

Jane Smith
Jack Wilson
`;

                const warnings = ValidationLogic.validateExpenses(input);

                test.assertEqual(warnings.length, 1);
                test.assertTrue(warnings[0].error.includes('ambiguous'));
            });

            test.test('detects person not found in expenses', () => {
                const input = `
John
50 Dinner - Bob

Jane
`;

                const warnings = ValidationLogic.validateExpenses(input);

                test.assertEqual(warnings.length, 1);
                test.assertTrue(warnings[0].error.includes('match'));
            });

            test.test('detects ambiguous person references in settlements', () => {
                const input = `
John Smith
50 > J

Jane Smith
`;

                const warnings = ValidationLogic.validateExpenses(input);

                test.assertEqual(warnings.length, 1);
                test.assertTrue(warnings[0].error.includes('ambiguous'));
            });

            test.test('detects person not found in settlements', () => {
                const input = `
John
50 > Bob

Jane
`;

                const warnings = ValidationLogic.validateExpenses(input);

                test.assertEqual(warnings.length, 1);
                test.assertTrue(warnings[0].error.includes('match'));
            });

            test.test('validates complex input with multiple errors', () => {
                const input = `
john
jane

John
50 Dinner - Bob, J
25 > Charlie
30 Lunch - jane`;

                const warnings = ValidationLogic.validateExpenses(input);

                test.assertTrue(warnings.length >= 3); // At least duplicate name, person not found, and ambiguous reference
            });

            test.test('handles valid input without warnings', () => {
                const input = `
John
50 Dinner - Jane, Bob
25 > Jane

Jane
30 Coffee

Bob`;

                const warnings = ValidationLogic.validateExpenses(input);

                test.assertEqual(warnings.length, 0);
            });

            test.test('handles empty participant lists correctly', () => {
                const input = `
John
50 Dinner -
25 Lunch -

Jane`;

                const warnings = ValidationLogic.validateExpenses(input);

                test.assertEqual(warnings.length, 0);
            });
        });

        test.suite('ExpenseLogic.parseExpenses - Validation Failure Tests', () => {
            test.test('throws error when duplicate names are present', () => {
                const input = `
John
Jane
john
Jane`;

                const error = test.assertThrows(() => {
                    ExpenseLogic.parseExpenses(input);
                }, 'Validation failed');

                test.assertTrue(error.message.includes('duplicate'));
            });

            test.test('throws error when ambiguous person references exist', () => {
                const input = `
John Smith
Jane Smith
Jack Wilson

John Smith
50 Dinner - J`;

                const error = test.assertThrows(() => {
                    ExpenseLogic.parseExpenses(input);
                }, 'Validation failed');

                test.assertTrue(error.message.includes('ambiguous'));
            });

            test.test('throws error when person not found in references', () => {
                const input = `
John
Jane

John
50 Dinner - Bob`;

                const error = test.assertThrows(() => {
                    ExpenseLogic.parseExpenses(input);
                }, 'Validation failed');

                test.assertTrue(error.message.includes('match'));
            });

            test.test('throws error when settlement references invalid person', () => {
                const input = `
John
Jane

John
50 > Bob`;

                const error = test.assertThrows(() => {
                    ExpenseLogic.parseExpenses(input);
                }, 'Validation failed');

                test.assertTrue(error.message.includes('match'));
            });

            test.test('throws error with multiple validation errors', () => {
                const input = `
John
jane
John Smith

John
50 Dinner - Bob, J
25 > Charlie`;

                const error = test.assertThrows(() => {
                    ExpenseLogic.parseExpenses(input);
                }, 'Validation failed');

                // Should contain multiple error messages
                test.assertTrue(error.message.split('\n').length > 2);
            });

            test.test('succeeds with valid input', () => {
                const input = `
John
50 Dinner - Jane, Bob
25 > Jane

Jane
30 Coffee

Bob`;

                const result = ExpenseLogic.parseExpenses(input);
                test.assertEqual(Object.keys(result.people).length, 3);
                test.assertEqual(result.transactions.length, 3);
            });

            test.test('succeeds with empty participant lists', () => {
                const input = `
John
50 Dinner -
25 Lunch -

Jane`;

                const result = ExpenseLogic.parseExpenses(input);
                test.assertEqual(Object.keys(result.people).length, 2);
            });
        });

        test.suite('Test Framework Validation', () => {
            test.test('assertApproxEqual works with positive tolerance', () => {
                // These should pass
                test.assertApproxEqual(1.001, 1.000, 0.01);
                test.assertApproxEqual(1.000, 1.001, 0.01);
                test.assertApproxEqual(10.05, 10.03, 0.05);
            });

            test.test('assertApproxEqual works with negative tolerance input', () => {
                // Should handle negative tolerance by taking absolute value
                test.assertApproxEqual(1.001, 1.000, -0.01);
                test.assertApproxEqual(1.000, 1.001, -0.01);
            });

            test.test('assertApproxEqual fails when difference exceeds tolerance', () => {
                let errorThrown = false;
                try {
                    test.assertApproxEqual(1.1, 1.0, 0.05);
                } catch (error) {
                    errorThrown = true;
                    test.assertTrue(error.message.includes('Expected approximately 1'), 'Error message should contain expected value');
                    test.assertTrue(error.message.includes('got 1.1'), 'Error message should contain actual value');
                    test.assertTrue(error.message.includes('±0.05'), 'Error message should show tolerance');
                    test.assertTrue(error.message.includes('difference: 0.1'), 'Error message should show actual difference');
                }
                test.assertTrue(errorThrown, 'Should throw error when difference exceeds tolerance');
            });

            test.test('assertApproxEqual works with zero values', () => {
                test.assertApproxEqual(0, 0, 0.01);
                test.assertApproxEqual(0.005, 0, 0.01);
                test.assertApproxEqual(-0.005, 0, 0.01);
            });

            test.test('assertApproxEqual works with negative values', () => {
                test.assertApproxEqual(-1.001, -1.000, 0.01);
                test.assertApproxEqual(-10.05, -10.03, 0.05);
            });

            test.test('assertThrows works correctly', () => {
                // Should catch thrown errors
                const error = test.assertThrows(() => {
                    throw new Error('Test error message');
                }, 'Test error');

                test.assertTrue(error.message.includes('Test error message'));
            });

            test.test('assertThrows fails when no error is thrown', () => {
                let testFailed = false;
                try {
                    test.assertThrows(() => {
                        // This function doesn't throw
                        return 42;
                    });
                } catch (error) {
                    testFailed = true;
                    test.assertTrue(error.message.includes('Expected function to throw an error'));
                }
                test.assertTrue(testFailed, 'assertThrows should fail when function does not throw');
            });

            test.test('assertThrows validates error message', () => {
                let testFailed = false;
                try {
                    test.assertThrows(() => {
                        throw new Error('Wrong message');
                    }, 'Expected message');
                } catch (error) {
                    testFailed = true;
                    test.assertTrue(error.message.includes('Expected error message to contain'));
                }
                test.assertTrue(testFailed, 'assertThrows should fail when error message does not match');
            });
        });

        // Run all tests when page loads
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                test.run();
            });
        } else {
            // Document already loaded
            test.run();
        }
    </script>
</body>
</html>
